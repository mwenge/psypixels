\chapter{Let's Pretend We Can Read Code} 
\label{sec:commentary}
\lstset{style=6502Style}
The listing is so short that it possible (and hopefully not too tedious) for us to
review it in its entirety. This will allow us to understand the basic workings of 
a small 'game' such as this one, from booting to running; it will also give us an
accurate idea of how the final 'Psychedelia' product worked. The difference between
the released game and the listing that appeared in Popular Computing Weekly is not
qualitative - the underlying structure is the same, the core routines we reviewed 
in the previous chapter are more or less identical. The differences lie only in the
the wealth of options available, so it turns out that the listing is an ideal way
for us to get our heads around the core mechanics of the light synthesizer. In the
chapters that follow we can look at some of the features added to the game in more
detail and concentrate on the individual routines that made them work. Here we will
focus instead on the high-level operation of the game and hopefully obtain a sense
of how the thing hangs together.

For the most part I try to present the code in the order it appears in the game
binary itself, but I have moved some routines around here and there so that we're
reading the code in an order that makes sense to the reader.

\clearpage
\begin{lstlisting}[caption=The bootstrap routine common to nearly every C64 program]
* = $0801
;-----------------------------------------------------
; Sys2064
;------------------------------------------------------
Sys2064
        .BYTE $0B,$08,$0A,$00
        .BYTE $9E             ; $9E = SYS
        .BYTE $32,$30,$36,$34 ; $32,$30,$36,$34 = 2064
        .BYTE $00,$00,$00,$00,$00,$00
\end{lstlisting}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\begin{lstlisting}[caption=Some strictly unnecessary code copying]
RAM0835LoPtr                        = $FD
RAM0835HiPtr                        = $FE
RAM4000HiPtr                        = $FC
RAM4000LoPtr                        = $FB
;---------------------------------------------------
; CopyCodeToRAM
;----------------------------------------------------
CopyCodeToRAM
        LDA #$40
        STA RAM4000HiPtr
        LDA #$08
        STA RAM0835HiPtr
        LDA #$00
        STA RAM4000LoPtr
        LDA #$35
        STA RAM0835LoPtr
        LDY #$00                                 
        LDX #$06
CopyLoop   
        LDA (RAM0835LoPtr),Y
        STA (RAM4000LoPtr),Y
        DEY 
        BNE CopyLoop
        INC RAM4000HiPtr
        INC RAM0835HiPtr
        DEX 
        BNE CopyLoop

        JMP InitializeProgram

\end{lstlisting}
\clearpage
\textbf{Lines 46-50. \icode{\textbf{Sys2064}}:} Yay, let's do some admin like starting the program! All C64 programs 
begin execution at position \icode{\$0801}, it's the law.
So every C64 program has a little section like this that the C64 executes first and which tells the C64 what to do next.
Here we tell it to start execution at another location \icode{\$0810}. Since we're currently at location \icode{\$0801}, that's
almost 16 bytes ahead and contains the code we've labelled \icode{CopyCodeToRAM} which we jump to next.

The command is given in a slightly strange way. Not strange for the time, but an oddly convoluted convention in its own right.
The \icode{SYS} command is followed by the a series of PETSCII values forming the decimal number 2064. In hexadecimal this is
\icode{\$0810} which is the actual location to start executing. So \icode{SYS 2064} as given by \icode{\$9E \$32\$ 30 \$36,\$34}
means 'start executing whatever is at memory location \icode{\$0810}'. Which in this case is \icode{CopyCodeToRAM}.

\bigskip
\bigskip
\textbf{Lines 56-75. \icode{\textbf{CopyCodeToRam}}:} Little Commodore 64 programs sure do like copying things around. This routine copies the entire code of the program to a
completely new position in memory at location \icode{\$4000} and then jumps to the routine \icode{InitializeProgram} that will actually start running
'Psychedelia'.

I think this was some sort of cheap and dirty copy protection, designed to prevent people from casually disassembling the
program if they felt minded to do so. 

\clearpage
\begin{lstlisting}[caption=The initialization routine - visited only once\, at the very start of execution]
NUM_COLS  = $28
NUM_ROWS  = $18
COLOR_RAM = $D800
;-------------------------------------------------------
; InitializeProgram
;-------------------------------------------------------
InitializeProgram   
        LDA #BLACK
        STA $D020    ;Border Color
        STA $D021    ;Background Color 0

PrepareHiLoPtrs
        LDA #>COLOR_RAM
        STA colorRamHiPtr
        LDA #<COLOR_RAM
        STA colorRamLoPtr

        LDX #$00
FillLinePointerLoop
        LDA colorRamHiPtr
        STA colorRAMLineTableHiPtrArray,X
        LDA colorRamLoPtr
        STA colorRAMLineTableLoPtrArray,X
        CLC 
        ADC #NUM_COLS
        STA colorRamLoPtr
        LDA colorRamHiPtr
        ADC #$00
        STA colorRamHiPtr
        INX 
        CPX #NUM_ROWS+1
        BNE FillLinePointerLoop

        JSR InitializeScreenAndText
        JMP LaunchPsychedelia

\end{lstlisting}
\clearpage

\textbf{Lines 82-113. \icode{\textbf{InitializeProgram}}:} More admin!  First we set the background and border color to black by loading
\icode{\$00} to the memory locations \icode{\$D020} for the border and \icode{\$D021} for the background color.

\bigskip
\bigskip
\textbf{Lines 90-93. \icode{\textbf{PrepareHiLoPtrs}}:} \icode{COLOR\_RAM} (\icode{\$D800}) is the address at which Color RAM starts. Color
RAM is a region of memory 1000 bytes long that contains the color value for each of the 25 rows of 40 characters that get displayed on the
screen. 

In order to be able to work with this address we need to have a way of working with values that are two bytes long even though
our 6502 instruction set only accomodates single byte values. To do this we have to split the address in two and store each half in 
a separate variable. \icode{LDA \#>COLOR\_RAM} is an assembly language convention for referencing the first byte in the two byte address
\icode{COLOR\_RAM}, i.e \icode{\$D800}. So another way of writing it is simply: \icode{LDA \#\$D8}. Likewise \icode{LDA \#<COLOR\_RAM} is
another way of writing \icode{LDA \#\$00}. 

We're storing each of these values in \icode{colorRamHiPtr} and \icode{colorRamLoPtr} respectively
as we're going to use them to populate a pair of arrays with each half of the addresses of each of the 25 rows on the screen.


\bigskip
\bigskip
\textbf{Lines 101-113. \textbf{\icode{FillLinePointerLoop}}:} Here we set up the pair of arrays that Psychedelia will make heavy use of:
\icode{colorRAMLineTableHiPtrArray} and \icode{colorRAMLineTable\-LoPtrArray}.
Together these arrays will function as a map on to the screen for drawing our pixels. Since the Commodore 64 screen is 25 rows high we make each array
25 elements long and together each element in each array will combine to give the address on the screen for the start of each row.
\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=8cm,center}
      \begin{tabular}{cccc}
        \toprule
        Element &
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{HiPtrArray}} & 
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{LoPtrArray}} & 
        Address \\
        \midrule
0 & \icode{\$D8} & \icode{\$00} & \icode{\$D800} \\ 
1 & \icode{\$D8} & \icode{\$28} & \icode{\$D828} \\ 
. & . & . & .\\
6 & \icode{\$D8} & \icode{\$F0} & \icode{\$D8F0} \\ 
. & . & . & .\\
23 & \icode{\$DB} & \icode{\$70} & \icode{\$DB70} \\ 
24 & \icode{\$DB} & \icode{\$98} & \icode{\$DB98} \\ 
        \bottomrule
      \end{tabular}
    \end{adjustbox}
  }\caption{Our two arrays and their contents - each combining to give us an address for the start of each row in Color RAM. }
\end{figure}

So in practice what this gives us is a 'single array' with which we can address each row on the screen and write color values
to the pixel position of our choice.

\input{listing_commentary/screen_table}

For example, to make the pixel on row 7 and column 15 red above, we have written a value of \icode{02} to the address \icode{\$D8FF}. This 
address is
formed from adding \icode{\$D8F0} (the 7th element in our array) + 15, i.e. \icode{\$D8F0} + \icode{\$0F} = \icode{\$D8FF}. 
To actually do this we would do something like the following:
 
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    RED = $02
    ; Load the 7th element from each array.
    LDX #$06
    ; This stores $F0 in currentLineInColorRamLoPtr
    LDA colorRAMLineTableLoPtrArray,X
    STA currentLineInColorRamLoPtr
    ; This stores $D8 in currentLineInColorRamHiPtr
    LDA colorRAMLineTableHiPtrArray,X
    STA currentLineInColorRamHiPtr
    ; Load $02, i.e. RED, to the Accumulator. 
    LDA #RED
    ; Y will be our index so give it the offset into the
    ; line, i.e. 15. 
    LDY #$0F
    ; Write $02 to address $DBFF, painting it red.
    STA (currentLineInColorRamLoPtr),Y
\end{lstlisting}

This gives us an idea of how the array will be used, but let's remind ourselves that all we are doing here is setting
it up in the first place. This consists of iterating from 0 to 24 and populating each element in our two arrays with
the appropriate value for the line on the screen each element represents. So at each iteration we store
the current values into the current position in the array given by \icode{X}:

\begin{lstlisting}
FillLinePointerLoop
        LDA colorRamHiPtr
        STA colorRAMLineTableHiPtrArray,X
        LDA colorRamLoPtr
        STA colorRAMLineTableLoPtrArray,X
\end{lstlisting}

Then we add  \icode{NUM\_COLS} (i.e. 40) to \icode{colorRamLoPtr}: 

\begin{lstlisting}
        CLC 
        ADC #NUM_COLS
        STA colorRamLoPtr
\end{lstlisting}

Finally we use \icode{ADC \$00} to ensure any carry from the previous addition is added to \icode{colorRamHiPtr}. 

\begin{lstlisting}
        LDA colorRamHiPtr
        ADC #$00
        STA colorRamHiPtr
\end{lstlisting}

This succesfully increments both \icode{colorRamLoPtr} and \icode{colorRamHiPtr} for storage in the next position in
the array. Finally the loop will stop when \icode{X} eventually reaches \icode{NUM\_ROWS} + 1, that is, once we have
populated an element in the array for every row:

\begin{lstlisting}
        INX 
        CPX #NUM_ROWS+1
        BNE FillLinePointerLoop
\end{lstlisting}
%\input{listing_commentary/titlescreen_color_ram_stripes}

\clearpage
\begin{lstlisting}[caption = A routine that fills the screen with black and the title text.]
bannerText   
        .TEXT $00,"PSYCHEDELIA...A FORETASTE BY JEFF MINTER"

;-------------------------------------------------------
; InitializeScreenAndText
;-------------------------------------------------------
InitializeScreenAndText   
        JSR InitializeScreen

        LDX #NUM_COLS
b452D   LDA bannerText,X
        STA SCREEN_RAM + $03BF,X
        LDA #WHITE
        STA COLOR_RAM + $03BF,X
        DEX 
        BNE b452D
        RTS 
\end{lstlisting}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\begin{lstlisting}[caption = Fills the screen with black]
;-------------------------------------------------------
; InitializeScreen
;-------------------------------------------------------
InitializeScreen   
        LDX #$00
b4034   LDA #$CF
        STA SCREEN_RAM + $0000,X
        STA SCREEN_RAM + $0100,X
        STA SCREEN_RAM + $0200,X
        STA SCREEN_RAM + $0300,X
        LDA #BLACK
        STA COLOR_RAM + $0000,X
        STA COLOR_RAM + $0100,X
        STA COLOR_RAM + $0200,X
        STA COLOR_RAM + $0300,X
        DEX 
        BNE b4034
        RTS 

\end{lstlisting}
\clearpage

\textbf{Lines 715-725. \icode{\textbf{InitializeScreenAndText}}:} Populates the screen with the banner text. The same loop writes
the text (contained in \icode{bannerText}) to the Screen RAM and sets the color of each character to white by writing the
value \icode{\$0C} (White) to the Color RAM.

\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/foretaste.png}
  \caption*{The screen after \icode{InitializeScreenAndText} has worked its magic.}
\end{figure}

\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 118-132. \icode{\textbf{InitializeScreen}}:} This fills the screen with black boxes. These are the boxes we will color in each time we paint a pixel.
As mentioned before there are two components to writing a character to a screen. The first is the character
itself, the second is the color(s) of the character. Psychedelia works by drawing the same character at every
position but painting it black if its empty or filling it with color if it should be displayed. So when
we initialize the screen we paint a box at every position and paint it black.

\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/black.png}
  \caption*{The screen after \icode{InitializeScreen} has painted it black.}
\end{figure}

\clearpage
\begin{lstlisting}[caption = Hopefully this looks familiar.]
starOneXPosArray
  .BYTE $00,$01,$01,$01,$00,$FF,$FF,$FF,$55       ;        5       
  .BYTE $00,$02,$00,$FE,$55                       ;                
  .BYTE $00,$03,$00,$FD,$55                       ;       4 4      
  .BYTE $00,$04,$00,$FC,$55                       ;        3       
  .BYTE $FF,$01,$05,$05,$01,$FF,$FB,$FB,$55       ;        2       
  .BYTE $00,$07,$00,$F9,$55                       ;        1       
  .BYTE $55                                       ;   4   000   4  
starOneYPosArray
  .BYTE $FF,$FF,$00,$01,$01,$01,$00,$FF,$55       ; 5  3210 0123  5
  .BYTE $FE,$00,$02,$00,$55                       ;   4   000   4  
  .BYTE $FD,$00,$03,$00,$55                       ;        1       
  .BYTE $FC,$00,$04,$00,$55                       ;        2       
  .BYTE $FB,$FB,$FF,$01,$05,$05,$01,$FF,$55       ;        3       
  .BYTE $F9,$00,$07,$00,$55                       ;       4 4      
  .BYTE $55                                       ;                
                                                  ;        5       
\end{lstlisting}

\bigskip
\begin{lstlisting}[caption= Random\, unused\, feels like a metaphor.]
randomByteAddress=$414E
;-------------------------------------------------------
; PutRandomByteInAccumulator
;-------------------------------------------------------
PutRandomByteInAccumulator   
        LDA $E199,X
        INC randomByteAddress
        RTS 
\end{lstlisting}
\bigskip
\begin{lstlisting}[caption = Fill our pixel arrays with zeros.]
;-------------------------------------------------------
; ReinitializeSequences
;-------------------------------------------------------
ReinitializeSequences   
        LDX #$00
        TXA 
ReinitializeLoop   
        STA pixelXPositionArray,X
        STA pixelYPositionArray,X
        STA currentColorIndexArray,X
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X
        INX 
        CPX #$40
        BNE ReinitializeLoop
        RTS 

\end{lstlisting}
\clearpage

\textbf{Lines 300-313. \icode{\textbf{starOneXPosArray}}:} We've encountered this data structure in previous chapters. It encodes the pattern used in the listing.
Psychedelia itself uses many different patterns and we explore these in detail in
\hyperref[sec:patterns]{\textcolor{blue}{our chapter on Patterns.}} 

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 321-327. \icode{\textbf{PutRandomByteInAccumulator}}:} This routine is unused in the listing, but is used by the commercial version of 'Psychedelia'. This is
presumably a product of taking the commercial source code and reducing it down for the listing but 
leaving this in by accident.

\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 434-445. \icode{\textbf{ReinitializeSequences}}:} This is a loop that fills the 5 arrays defined on the next page with zeroes.
\icode{TXA} loads the value of \icode{\$00} previously loaded to \icode{X} to the \icode{A} register, so it could as easily be \icode{LDA \$00}
however it has the dubious advantage of being one byte shorter as an instruction.

Notice that \icode{X} gets incremented on each pass of the loop until it reaches \icode{\$40} - filling all 64 elements of each array with
\icode{\$00}.
\clearpage
\begin{lstlisting}[caption = The pixel buffers\, each 64 bytes long though only 32 bytes are used in this version thanks to \icode{MAX\_INDEX\_VALUE}
being set to \icode{\$1F} (32).]
countToMatchCurrentIndex      .BYTE $01
MAX_INDEX_VALUE               .BYTE $1F
pixelXPositionArray   
        .BYTE $0F,$0E,$0D,$0C,$0B,$0A,$09,$04
        .BYTE $05,$06,$07,$08,$09,$0A,$0B,$0C
        .BYTE $0D,$0E,$0F,$10,$11,$12,$13,$14
        .BYTE $15,$16,$17,$14,$13,$12,$11,$10
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
pixelYPositionArray   
        .BYTE $0C,$0D,$0E,$0F,$0F,$0F,$0E,$04
        .BYTE $04,$04,$04,$04,$04,$04,$04,$05
        .BYTE $06,$07,$08,$09,$0A,$0B,$0C,$0D
        .BYTE $0D,$0D,$0D,$07,$09,$09,$0A,$0B
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
currentColorIndexArray   
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
initialSmoothingDelayForStep   
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
smoothingDelayForStep   
        .BYTE $04,$07,$01,$02,$03,$06,$07,$06
        .BYTE $0C,$02,$03,$06,$07,$01,$02,$02
        .BYTE $04,$04,$07,$01,$02,$03,$06,$07
        .BYTE $0C,$02,$03,$02,$03,$07,$01,$02
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00


\end{lstlisting}
\clearpage

\textbf{Lines 385-429. \icode{\textbf{pixelXPositionArray}}:} Five arrays of 64 bytes each, though only the first 32 in each are actually used. This fact is determined
by the value of \icode{\$1F} (32) in \icode{MAX\_INDEX\_VALUE}. We see this being enforced on the next page in
\icode{MainPaintLoop}. Defining 64 bytes, but only using 32 in the end, suggests Minter had to play around
with the performance limitations of the C64. Since each byte represents a pattern that must be drawn and painted
at a given position in the screen, using all 64 by setting allocated \icode{MAX\_INDEX\_VALUE} to \icode{\$3F} 
was not necessarily prohibitive but certainly resulted in a more sluggish effect.

We've seen the first three arrays in use already when we looked at the core
pattern painting routine. Each byte in the array refers to a distinct step in the paint sequence.
\icode{pixelXPositionArray} and \icode{pixelYPositionArray} together define a location on the screen
that is treated as the origin for painting and drawing an instance of the current pattern. So for example \icode{\$0F,\$0C} given by the
first byte in each represents column 16 (\icode{\$0F}) and row 14 (\icode{\$0C}). The value in
the corresponding position of \icode{currentColorIndexArray} represents the color to 'start from'.


\clearpage
\begin{lstlisting}[caption= The game's main loop.]
;-------------------------------------------------------
; LaunchPsychedelia
;-------------------------------------------------------
LaunchPsychedelia   
        JSR ReinitializeSequences
        JSR SetUpIntteruptHandler

MainPaintLoop   
        ; Part 1: Check if it's time to paint.
        INC currentPositionInArrays
        LDA currentPositionInArrays
        AND MAX_INDEX_VALUE
        STA currentPositionInArrays
        TAX 
        DEC smoothingDelayForStep,X
        BNE GoBackToStartOfLoop

        ; Part 2: Check if there's a color to paint.
        LDA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X

        LDA currentColorIndexArray,X
        CMP #$FF
        BEQ GoBackToStartOfLoop

        ; Part 3: Actually do a paint.
ActuallyDoAPaint
        STA currentValueInColorIndexArray
        LDA pixelXPositionArray,X
        STA pixelXPosition
        LDA pixelYPositionArray,X
        STA pixelYPosition

        JSR PaintStructureAtCurrentPosition

        LDX currentPositionInArrays
        DEC currentColorIndexArray,X

GoBackToStartOfLoop   
        JMP MainPaintLoop

\end{lstlisting}

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
        \midrule
        \$20 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
        \$1F & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$20 and \$1F gives \$00, ensuring we always loop between 0 and 32.}
\end{figure}
\clearpage
\textbf{Lines 450-482. \icode{\textbf{LaunchPsychedelia}}:} Finally a routine that resembles getting down to business. We start by initializing the arrays we saw on the 
previous page to all zeros in \icode{ReinitializeSequences}. Next we set up the interrupt handler, which will
be responsible for processing user input. We'll take a look at this routine in more detail later on.

For now, what follows is the game's core loop. This runs forever, round and round, repeating all the steps between the
\icode{MainPaintLoop} and \icode{GoBackToStartOfLoop} labels. 

There are three parts to the code inside this loop. 

The first is visited on every journey through the loop and increments the
value stored in \icode{currentPositionInArrays}. It keeps this value looping between 0 and 32 by always \icode{AND}'ing
it with \icode{MAX\_INDEX\_VALUE}. This \icode{AND} operation ensures that once it reaches 33, for example, the result
goes back to zero. (See opposite page.)

Now that it has a new value in \icode{currentPositionInArrays} it transfers it to the \icode{X} register and uses the 
\icode{X} as in index into the \icode{smoothingDelayForStep} array (and all the other arrays) which we saw defined on the previous 
page. It decrements the byte at this index in the \icode{smoothingDelayForStep} array and if it has reached zero
proceeds to Part 2 of the loop, otherwise it jumps execution to \icode{GoBackToStartOfLoop}, which itself jumps execution
back to the top again at \icode{MainPaintLoop}. Back on the merry-go-round we go.

If we get to Part 2 this time round we first reset the value in the \icode{framesRemaining\-ToNextPaintForStep} array with an initial value for it kept in the corresponding
location of \icode{initialFramesRemaining\-ToNextPaintForStep}. We next check if we've run out of colors to paint for this step
in the sequence: if the value at the index position in \icode{currentColorIndexArray} has already reached \icode{\$FF} (because
it was decremented below zero and so cycled back to \icode{\$FF}) then there's nothing to paint and we jump back to the top
again via \icode{GoBackToStartOfLoop}. No colors means no painting after all!

If there actually, finally, is something to do for this position in the sequence we can pass to Part 3. Here we load up the X and Y
position to use from our \icode{pixelXPositionArray} and \icode{pixelYPositionArray} and do the actual painting work we covered
in our previous chapter, all of which happens in \icode{PaintStructureAtCurrentPosition}. As we saw this routine is the top of the
tree for the pixel painting routines in Psychedelia, and all it needed from us here was an X and Y position as well as a color
loaded from the \icode{currentColorIndexArray}. Equipped with that it can paint anything. 

\clearpage
\begin{lstlisting}[caption = The routine responsible for orchestrating the pattern painting.]
NUM_ARRAYS = $07
;-------------------------------------------------------
; PaintStructureAtCurrentPosition
;-------------------------------------------------------
PaintStructureAtCurrentPosition   
        JSR PaintPixelForCurrentSymmetry

        LDY #$00
        LDA currentValueInColorIndexArray
        CMP #NUM_ARRAYS
        BNE CanLoopAndPaint
        RTS 

CanLoopAndPaint   
        LDA #NUM_ARRAYS
        STA countToMatchCurrentIndex
       
        LDA pixelXPosition
        STA initialPixelXPosition
        LDA pixelYPosition
        STA initialPixelYPosition

LineReadLoop   
        ; See next page for the contents of this loop.
        JMP LineReadLoop

RestorePositionsAndReturn   
        LDA initialPixelXPosition
        STA pixelXPosition
        LDA initialPixelYPosition
        STA pixelYPosition
        RTS 

\end{lstlisting}
\clearpage

\textbf{Lines 217-285. \icode{\textbf{PaintStructureAtCurrentPosition}}:} To understand how this routine and the ones it calls on the subsequent pages hang together you should refer
back to the previous chapter. Here we will limit ourselves to explaining some of the detailed points of the
code.

The meat of this routine occurs in the \icode{LineReadLoop} section on the next page but here we can see the
gatekeeping and bookkeeping activities of the code before and after that central section. 

The first call to \icode{PaintPixelForCurrentSymmetry} paints a pixel at the current position given by 
\icode{pixelXPosition} and \icode{pixelYPosition}. The \icode{-CurrentSymmetry} part ensures that extra
pixels are projected along the axes given by the current symmetry setting. In our listing this is the
X-axis, ensuring we always paint two patterns. We'll look at this in a little more detail later.

Next we figure out if we should just return early from this routine and do nothing further. This will be the
case if \icode{currentValueInColorIndexArray} is still at the same value as \icode{NUM\_ARRAYS} (7). If it is
we return from the routine straight away (\icode{RTS}) and
\icode{MainPaintLoop} will decrement it the next time around for this position
in the sequence and we can paint an actual color.

You cans see that before and after the \icode{LineReadLoop} section we're storing the values in \icode{pixelX/YPosition} in
\icode{initialPixelX/YPosition} and then restoring them when the loop is over. This is because \icode{LineReadLoop}
will frequently overwrite the values as it iterates through the positions given in the pattern array \icode{starOneX/YPosArray}.

\clearpage
\begin{lstlisting}[caption=The core pattern-painting loop.]
LineReadLoop   
        LDA initialPixelXPosition
        CLC 
        ADC starOneXPosArray,Y
        STA pixelXPosition

        LDA initialPixelYPosition
        CLC 
        ADC starOneYPosArray,Y
        STA pixelYPosition

        TYA 
        PHA 

        JSR PaintPixelForCurrentSymmetry

        PLA 
        TAY 
        INY 

        LDA starOneXPosArray,Y
        CMP #$55
        BNE LineReadLoop

        DEC countToMatchCurrentIndex
        LDA countToMatchCurrentIndex
        CMP currentValueInColorIndexArray
        BEQ RestorePositionsAndReturn
        CMP #$01
        BEQ RestorePositionsAndReturn

        INY 
        JMP LineReadLoop

\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny]
starOneXPosArray
  .BYTE $00,$01,$01,$01,$00,$FF,$FF,$FF,$55       ;        5       
  .BYTE $00,$02,$00,$FE,$55                       ;                
  .BYTE $00,$03,$00,$FD,$55                       ;       4 4      
  .BYTE $00,$04,$00,$FC,$55                       ;        3       
  .BYTE $FF,$01,$05,$05,$01,$FF,$FB,$FB,$55       ;        2       
  .BYTE $00,$07,$00,$F9,$55                       ;        1       
  .BYTE $55                                       ;   4   000   4  
starOneYPosArray
  .BYTE $FF,$FF,$00,$01,$01,$01,$00,$FF,$55       ; 5  3210 0123  5
  .BYTE $FE,$00,$02,$00,$55                       ;   4   000   4  
  .BYTE $FD,$00,$03,$00,$55                       ;        1       
  .BYTE $FC,$00,$04,$00,$55                       ;        2       
  .BYTE $FB,$FB,$FF,$01,$05,$05,$01,$FF,$55       ;        3       
  .BYTE $F9,$00,$07,$00,$55                       ;       4 4      
  .BYTE $55                                       ;                
                                                  ;        5       
\end{lstlisting}
\clearpage

\textbf{Lines 239-278. \icode{\textbf{LineReadLoop}}:} A better name for this loop might be \icode{ThisIsWhereThe\-PsychedeliaHappens}. As I keep saying, we unpicked the mechanics
of the \icode{Paint\-StructureAtCurrentPosition} routine that this loop is a part of in the previous chapter so if you didn't understand my explanation there (definitely my doing if you didn't)
then I'm not sure I can do anything to retrieve the situation here.

So instead let's look at the detail of what's going on in the loop. \icode{Y} starts out at zero and gets incremented at
each pass through the loop. So the first paragraph adds the value at index 0 in \icode{starOneXPosArray} in this pass to \icode{initialPixelXPosition}
and stores it in \icode{pixelXPosition}. That value is \icode{\$00}, on the next it will be \icode{\$01}, on the pass after that
it will be \icode{\$01} again. You can hopefully see how the \icode{LDA}, \icode{ADC}, and \icode{STA} instructions are doing that
but you might wonder what the \icode{CLC} is about. This clears the CPU's 'Carry Bit' so that the addition performed by \icode{ADC}
doesn't inadvertently include any carries from previous addition operations in its result.

The next paragraph does the same for \icode{pixelYPosition} using the \icode{starOneXPosArray} array. But the paragraph after
that does something that requires explanation. It transfers the current value in the \icode{Y} register to the \icode{A} register
using the instruction \icode{TYA}. Then it pushes the \icode{A} register on to a thing called the 'Stack' using the instruction
\icode{PHA}. The 'Stack' is a stack of values that resembles a stack of plates: you add things to the top of it and take things
from the top of it. So when you take something from the stack using the complementary instruction \icode{PLA} you are taking
what was last put there (and not pulled off it before you).

So the \icode{TYA, PHA, PLA, TAY} sequence of instructions that surrounds our call to \icode{PaintPixelForCurrentSymmetry} has the
simple effect of ensuring that we keep our current value of \icode{Y} unmolested by whatever \icode{PaintPixelForCurrentSymmetry}
gets up to, because that can (and does) include populating and using the \icode{Y} register for other stuff. As you can imagine
this is a common technique in a CPU where there are only three free variables to play with (\icode{X,Y,A}) and you have more than three things
to worry about!

Next, after incrementing \icode{Y} (\icode{INY}) we check the next value in \icode{starOneXPosArray}. If it's \icode{\$55} then
we've reached the end of a line the pattern and must check whether we've read all the lines in the pattern we need to for this
round. If we have, then we return by calling \icode{RestorePositionsAndReturn}, otherwise we increment \icode{Y} again to read
in the first value of the next line and continue looping.

\clearpage
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,caption=Choosing what to paint based on the current symmetry setting.]
currentSymmetrySettingForStep   .BYTE $01
;-------------------------------------------------------
; PaintPixelForCurrentSymmetry
;-------------------------------------------------------
PaintPixelForCurrentSymmetry   
        ; First paint the normal pattern without any
        ; symmetry.
        LDA pixelXPosition
        PHA 
        LDA pixelYPosition
        PHA 
        JSR PaintPixel

        LDA currentSymmetrySettingForStep
        BNE HasSymmetry

CleanUpAndReturnFromSymmetry   
        PLA 
        STA pixelYPosition
        PLA 
        STA pixelXPosition
        RTS 

HasSymmetry   
        ; Has a pattern to paint on the X axis
        ; symmetry so prepare for that.
        LDA #NUM_COLS
        SEC 
        SBC pixelXPosition
        STA pixelXPosition

        JSR PaintPixel

        LDA currentSymmetrySettingForStep
        CMP #$01
        BEQ CleanUpAndReturnFromSymmetry

        LDA #NUM_ROWS
        SEC 
        SBC pixelYPosition
        STA pixelYPosition
        JSR PaintPixel

        PLA 
        TAY 
        PLA 
        STA pixelXPosition
        TYA 
        PHA 
        JSR PaintPixel
        PLA 
        STA pixelYPosition
        RTS 

\end{lstlisting}
\clearpage

\textbf{Lines 332-382. \icode{\textbf{PaintPixelForCurrentSymmetry}}:} This routine is concerned entirely with setting up the values of \icode{pixelXPosition} and \icode{pixelYPosition} correctly
for calling the routine \icode{PaintPixel}. The reason this is necessary is that the commercial version of Psychedelia
has up to 4 different arrangements or 'symmetries' for painting the chosen pattern. The simplest arrangement is just to 
paint one copy of the pattern and be done. The first paragraph here takes care of that, no matter what arrangement we're
painting we're always painting the pattern at least once. 

While the commercial version has at least three others to worry about, and offers the user a way of switching between each,
the listing edition hard-codes a single behaviour of always painting the pattern twice, reflected on the X-axis in a kind of mirror
arrangement. This behaviour is defined by the value in \icode{currentSymmetrySettingForStep} and as we can see opposite it
is hard-coded to \icode{\$01}. Because it is set to a non-zero value, \icode{BNE HasSymmetry} always returns true and execution
jumps to \icode{HasSymmetry}.

\icode{HasSymmetry} calculates the reflected position on the X-axis for the pattern by simply subtracting the current value
of \icode{pixelXPosition} from the total number of columns in the screen (which is 40). This has the neat effect of ensuring
the reflected position is always exactly opposite to the original pattern.

The paragraph after \icode{PaintPixel} always returns from the routine because as we saw \icode{currentSymmetrySettingForStep} is
hardcoded to \icode{\$01}. So the code after it is never executed and is redundant here. What it does is draw a full four-pattern
arrangement with reflections along the X and Y axes. If we set \icode{currentSymmetrySettingForStep} to \icode{\$02} and run the
listing we can see this in action.


\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/four_pattern.png}
  \caption*{The display with \icode{currentSymmetrySettingForStep} set to \icode{\$02}}
\end{figure}


\clearpage
\begin{lstlisting}[caption=Where the painting is actually done.]
presetColorValuesArray
;         0    6    2    4      5    3     7      1
  .BYTE BLACK,BLUE,RED,PURPLE,GREEN,CYAN,YELLOW,WHITE
;-------------------------------------------------------
; PaintPixel
;-------------------------------------------------------
PaintPixel   
        LDA pixelXPosition
        AND #$80 ; Detect if has moved off left of screen
        BNE ReturnEarly
        LDA pixelXPosition
        CMP #NUM_COLS
        BPL ReturnEarly
        LDA pixelYPosition
        AND #$80 ; Detect if has moved off top of screen.
        BNE ReturnEarly
        LDA pixelYPosition
        CMP #NUM_ROWS
        BPL ReturnEarly

        JSR LoadXAndYPosition
        LDA (currentLineForPixelInColorRamLoPtr),Y
        AND #COLOR_MAX

        LDX #$00
CheckPresetsLoop   
        CMP presetColorValuesArray,X
        BEQ MaybePaintPixel
        INX 
        CPX #COLOR_MAX + 1
        BNE CheckPresetsLoop

MaybePaintPixel   
        TXA 
        STA indexOfCurrentColor
        LDX currentValueInColorIndexArray
        INX 
        CPX indexOfCurrentColor
        BEQ ActuallyPaintPixel
        BPL ActuallyPaintPixel
        RTS 

ActuallyPaintPixel   
        LDX currentValueInColorIndexArray
        LDA presetColorValuesArray,X
        STA (currentLineForPixelInColorRamLoPtr),Y
        RTS 
\end{lstlisting}
\clearpage

\textbf{Lines 164-214. \icode{\textbf{PaintPixel}}:} The first paragraph searches for a reason to \icode{ReturnEarly}. The first
check, whether the pixel has moved beyond the leftmost position on the screen, is a good example of how assembly language involves
logic that might be unintuitive at first. In layman's terms we just want to ask is \icode{pixelXPosition} less than zero. One neat
way of doing this in our situation is to check if decrementing past \icode{\$00} has resulted in a value of \icode{\$FF}. Since
the rightmost position never exceeds \icode{\$40} this means we can just check if the leftmost bit on the value is set or not: if 
it is then we've gone below zero. So an \icode{AND \$80} check will do the job - if it returns true then we've gone below zero:

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
        \midrule
        \$FF & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
        \$80 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \midrule
        Result & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$FF and \$80 gives \$80, a non-zero value - so the \icode{AND} returns true.}
\end{figure}

If we get past these checks we can prepare ourselves for writing to the screen by calling \icode{LoadXAndYPosition}. As we can
see below this loads the \icode{Y} position to the \icode{X} register and the \icode{X} position to the \icode{Y} register. There
is a reason that this is what seems like the wrong way round - the use we intend to make of each register is constrained by the
rules of assembly language.

\begin{lstlisting}
LoadXAndYPosition   
        LDX pixelYPosition
        LDA colorRAMLineTableLoPtrArray,X
        STA currentLineForPixelInColorRamLoPtr
        LDA colorRAMLineTableHiPtrArray,X
        STA currentLineForPixelInColorRamHiPtr
        LDY pixelXPosition
        RTS 
\end{lstlisting}

\textbf{Lines 210-214. \icode{\textbf{ActuallyPaintPixel}}:} This is the rubber hitting the road. We're writing data to the
screen. Recall that our  \icode{colorRAMLineTableLoPtrArray} array is an array of 25 screen addresses each one pointing
to the start of a row. In \icode{LoadXAndYPosition} we have set up \icode{currentLineForPixelInColorRamLoPtr} and \icode{currentLine\-ForPixelInColorRamHiPtr} to contain the address of the pixel we want to paint. So for example if the address of Color RAM we want to populate
is \icode{\$D810} then \icode{currentLineForPixelInColorRamLoPtr} will contain \icode{\$10} and \icode{currentLine\-ForPixelInColorRamHiPtr} will
contain \icode{\$D8}. 
\clearpage
\begin{lstlisting}[caption= Setting up our Interrupt Handler]
SetUpIntteruptHandler   
        SEI 
        LDA #<MainInterruptHandler
        STA $0314    ;IRQ
        LDA #>MainInterruptHandler
        STA $0315    ;IRQ

        LDA #$0A
        STA cursorXPosition
        STA cursorYPosition

        LDA #$01
        STA $D015    ;Sprite display Enable
        STA $D027    ;Sprite 0 Color
        CLI 
        RTS 
\end{lstlisting}
\clearpage
\textbf{Lines 491-506. \icode{\textbf{SetUpInterruptHandler}}:} What is an Interrupt Handler when it's at home and why are
we setting one up?

Recall that this routine was called immediately before we entered the main loop. It is only ever called once:
\begin{lstlisting}
LaunchPsychedelia   
        JSR ReinitializeSequences
        JSR SetUpIntteruptHandler
\end{lstlisting}

In plain English, an 'interrupt' is when the CPU periodically stops what ever its doing and does some other pre-defined amount
of work instead. There are a few such interrupts supported by the 6502 CPU but the one we make use of here is called the IRQ
or 'Hardware Interrupt'. This interrupt runs 60 times a second (that's right, 60 times a second) and already has some work
assigned to it by the Commodore 64, a set of tasks such as checking keyboard and joystick input that is defined at address \icode{\$EA31}.
This doesn't have a proper name of it's own so we will call it \icode{DEFAULT\_IRQ\_HANDLER}. (The routine called by an interrupt
is often referred to as an 'interrupt vector'.)

What we can do is tag some work of our own onto this, we still need to call the routine at \icode{\$EA31} but we can do some of our
own stuff before it. The way to do this is to load the address of our own routine, which we call \icode{MainInterruptHandler}, to
the address that the 6502 CPU consults each time it interrupts its work. We replace \icode{\$EA31} at that address with the address
of \icode{MainInterruptHandler}.  
\begin{lstlisting}
        SEI 
        LDA #<MainInterruptHandler
        STA $0314    ;IRQ
        LDA #>MainInterruptHandler
        STA $0315    ;IRQ
        ...
        CLI 
\end{lstlisting}

Notice that because the address is two bytes long we must split it out, like we did for our Colour RAM address earlier, into 
two bytes and store each one separate in the consecutive address locations \icode{\$0314} and \icode{\$0315}, which store
the second and first byte of the interrupt-handler address respectively. 

The \icode{SEI} instruction at the beginning of this routine and the \icode{CLI} instruction at the end tell the CPU that we 
are updating the interrupt vector. The \icode{SEI} ensures that no further interrupts happen while we are doing this, and the
\icode{CLI} gives the CPU the all-clear to start honouring interrupts again now that we've updated the routine it should call
when one happens.


\clearpage
\begin{lstlisting}[caption= This is our interrupt handler\, it runs 60 times a second so has to be fast.]
MainInterruptHandler   
        DEC countStepsBeforeCheckingJoystickInput
        BEQ PaintCursorAndCheckJoystickInput
        JMP DEFAULT_IRQ_HANDLER

PaintCursorAndCheckJoystickInput   
        LDA #$02
        STA countStepsBeforeCheckingJoystickInput
        LDA #$00
        STA currentColorToPaint
        JSR PaintCursorAtCurrentPosition

CheckIfJoystickMovedUpOrDown   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$03
        CMP #$03
        BEQ CheckIfPlayerPressedLeftOrRight

        CMP #$02
        BEQ PlayerHasPressedDown

PlayerHasPressedUp
        ; Player has pressed up. Incremeent up two lines
        ; so that when we decrement down one, we're still
        ; one up!
        INC cursorYPosition
        INC cursorYPosition

PlayerHasPressedDown   
        DEC cursorYPosition
        LDA cursorYPosition
        CMP #$FF
        BNE CheckIfCursorAtBottom

WrapCursorToBottom
        ; Cursor has reached the top of the screen, so loop
        ; around to bottom.
        LDA #NUM_ROWS - 1
        STA cursorYPosition
        JMP CheckIfPlayerPressedLeftOrRight

CheckIfCursorAtBottom   
        CMP #NUM_ROWS
        BNE CheckIfPlayerPressedLeftOrRight
        ; Cursor has reached the bottom of the screen, so loop
        ; around to top
        LDA #$00
        STA cursorYPosition

\end{lstlisting}
\clearpage

\textbf{Lines 491-506. \icode{\textbf{MainInterruptHandler}}:}  You don't have to look too hard at our interrupt handler
to divine what is is mainly concerned with: have you moved the joystick or pressed fire? The routine is long enough
that we need to spread it over 3 pages here. The section on the opposite page gets as far as reacting to any up or
down movement in the joystick and the beginnings of the left/right checks. 

Joystick input is read from the \icode{CIA1 Data Port Register}. If the player interacts with the joystick at all it will
show up in the byte at address \icode{\$DC00}. Only 5 of the 8 bits are used, 4 for each direction and 1 for the fire button.
Counter-intuitively, the bits are set to \icode{1} by default, so you can tell if a button has been pressed or the joystick moved
if one of the appropriate bits is \icode{0} rather than \icode{1}.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$FD & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
        \bottomrule
      \end{tabular}
    \end{adjustbox}
  }\caption*{The contents of \icode{\$DC00} when the player has pressed down on the joystick.}
\end{figure}

\textbf{Lines 491-506. \icode{\textbf{CheckIfJoystickMovedUpOrDown}}:} If we \icode{AND} the value in \icode{\$DC00} (for
example, \icode{\$FE}) with
\icode{\$03} it will tell us if up or down have been pressed if the result is not equal to \icode{\$03}. This is because
we expect both bits to be 1 if up or down have not been pressed, and the \icode{AND} ensures we are only comparing those
two bits when we perform \icode{CMP \#\$03}.
\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$FE & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
        \$03 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$FE and \$03 gives \$02, telling us that 'Up' has been pressed.}
\end{figure}

Once we have established this we can increment and decrement \icode{cursorYPosition} as appropriate and also check
if we've reached the top or bottom of the screen. 
\clearpage
\begin{lstlisting}[caption= Second part of the Interrupt Handler.]
CheckIfPlayerPressedLeftOrRight   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$0C
        CMP #$0C
        BEQ CheckIfPlayerPressedFire

        CMP #$08
        BEQ PlayerHasPressedLeft

PlayerHasPressedRight
        ; Player has pressed right.
        INC cursorXPosition
        INC cursorXPosition

PlayerHasPressedLeft   
        DEC cursorXPosition
        LDA cursorXPosition
        CMP #$FF
        BNE CheckIfCursorAtExtremeRight

WrapCursorToExtremeRight
        LDA #NUM_COLS - 1
        STA cursorXPosition
        JMP CheckIfPlayerPressedFire

CheckIfCursorAtExtremeRight   
        CMP #NUM_COLS
        BNE CheckIfPlayerPressedFire
        LDA #$00
        STA cursorXPosition

\end{lstlisting}
\clearpage
\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedLeftOrRight}}:} As in the previous page, which was checking
for up/down movement, here we're checking for left/right movement in the joystick and updating the \icode{cursorXPosition} if required.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$F7 & 1 & 1 & 1 & 1 & 0 & 1 & 1 & 1 \\
        \$0C & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$F7 and \$0C gives \$04, telling us that 'Left' has been pressed.}
\end{figure}

\clearpage
\begin{lstlisting}[caption= Third part of the Interrupt Handler.]
CheckIfPlayerPressedFire   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$10
        BEQ PlayerHasPressedFire

PlayerHasntPressedFire
        LDA #$00
        STA stepsSincePressedFire
        JMP DrawCursorAndReturnFromInterrupt

PlayerHasPressedFire
MaybeUpdatePixelBuffers   
        LDA unusedBurstMode
        BEQ UpdateArrayIndex

        LDA stepsSincePressedFire
        BNE DrawCursorAndReturnFromInterrupt
        INC stepsSincePressedFire

UpdateArrayIndex   
        INC indexIntoArrays
        LDA indexIntoArrays
        AND MAX_INDEX_VALUE
        STA indexIntoArrays

CheckCurrentIndexInBuffers  
        TAX 
        LDA currentColorIndexArray,X
        CMP #$FF
        BNE DrawCursorAndReturnFromInterrupt

UpdateBuffersWithCursorPosition
        LDA cursorXPosition
        STA pixelXPositionArray,X
        LDA cursorYPosition
        STA pixelYPositionArray,X
        LDA #COLOR_MAX
        STA currentColorIndexArray,X

        LDA smoothingDelay
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X

\end{lstlisting}
\clearpage

\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedFire}}:} This section of the routine could be much shorter. This
is because neither \icode{burstModeEnabled} nor \icode{stepsSincePressedFire} are actually used. The code that refers
to them seems to be concerned with supporting an unused feature toggled on/off by the variable \icode{burstModeEnabled}
and since it has been hardcoded to \icode{\$00} the section could be stripped back to this instead:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
CheckIfPlayerPressedFire   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$10
        BNE DrawCursorAndReturnFromInterrupt

PlayerHasPressedFire
        INC indexIntoArrays
        LDA indexIntoArrays
        AND MAX_INDEX_VALUE
        STA indexIntoArrays

CheckCurrentIndexInBuffers  
        TAX 
        LDA currentColorIndexArray,X
        CMP #$FF
        BNE DrawCursorAndReturnFromInterrupt

UpdateBuffersWithCursorPosition
        LDA cursorXPosition
        STA pixelXPositionArray,X
        LDA cursorYPosition
        STA pixelYPositionArray,X
        LDA #COLOR_MAX
        STA currentColorIndexArray,X

        LDA smoothingDelay
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X
\end{lstlisting}

This refactored version makes it much easier to see what's going on: if the player has pressed fire then we increment
our index into the pixel arrays and load the cursor's position to the index's position in \icode{pixelXPositionArray/pixelYPositionArray}
and initial values to the arrays managing pixel color and smoothing delay.

If the player hasn't pressed fire or if our current index to the arrays points to a position that is already being used then
we skip to just painting the cursor and exiting. Note that our heuristic for deciding whether the current position in the 
arrays is in use is to make sure that the value at \icode{indexIntoArrays} in \icode{currentColorIndexArray} is \icode{\$FF} - 
after all, this will only be the case if we haven't already used it (or used it up).

\clearpage
\clearpage
\begin{lstlisting}[caption = Paint the cursor and call the system default interrupt handler \icode{RETURN\_FROM\_INTERRUPT}]
DrawCursorAndReturnFromInterrupt   
        JSR LoadXAndYOfCursorPosition
        LDA (currentLineForCursorInColorRamLoPtr),Y
        AND #COLOR_MAX
        STA lastColorPainted
        LDA #WHITE
        STA currentColorToPaint
        JSR PaintCursorAtCurrentPosition
        JMP RETURN_FROM_INTERRUPT

\end{lstlisting}

\bigskip
\begin{lstlisting}[caption= Load the X and Y position and set up \icode{currentLineForCursorInColorRamLoPtr/currentLineForCursorInColorRamHiPtr}
for painting the cursor.]
LoadXAndYOfCursorPosition   
        LDX cursorYPosition
        LDA colorRAMLineTableLoPtrArray,X
        STA currentLineForCursorInColorRamLoPtr
        LDA colorRAMLineTableHiPtrArray,X
        STA currentLineForCursorInColorRamHiPtr
        LDY cursorXPosition
        RTS 
\end{lstlisting}
\bigskip
\begin{lstlisting}[caption = Paint the cursor.]
PaintCursorAtCurrentPosition   
        JSR LoadXAndYOfCursorPosition
        LDA currentColorToPaint
        STA (currentLineForCursorInColorRamLoPtr),Y
        RTS 
\end{lstlisting}
\clearpage
\textbf{Lines 300-313. \icode{\textbf{starOneXPosArray}}:} 

