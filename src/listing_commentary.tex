\chapter{let's pretend we can read code} 
\label{sec:commentary}
\rhead[]{\leftmark}
\lstset{style=6502Style}
\lstset{ 
   aboveskip=5pt,
   belowskip=0pt,
}
The listing is so short that it possible (and hopefully not too tedious) for us to
review it in its entirety. This will allow us to understand the basic workings of 
a small 'game' such as this one, from booting to running; it will also give us an
accurate idea of how the final 'Psychedelia' product worked. The difference between
the released game and the listing that appeared in Popular Computing Weekly\index{Popular Computing Weekly} is not
qualitative - the underlying structure is the same, the core routines we reviewed 
in the previous chapter are more or less identical. The differences lie only in the
the wealth of options available, so it turns out that the listing is an ideal way
for us to get our heads around the core mechanics of the light synthesizer. In the
chapters that follow we can look at some of the features added to the game in more
detail and concentrate on the individual routines that made them work. Here we will
focus instead on the high-level operation of the game and hopefully obtain a sense
of how the thing hangs together.

For the most part I try to present the code in the order it appears in the game
binary itself, but I have moved some routines around here and there so that we're
reading the code in an order that makes sense to the reader.

Before we drive into the weeds, let's take an aerial view of the code over the next
few pages. This gives us a proper sense of how small the program is and also where
things are in the listing, how it is ordered, and what, if any, structure it possesses.

\subfile{listing_commentary/psychedelia_listing.tex}
\clearpage
\textbf{Lines 46-50. \icode{\textbf{Sys2064}}}
\begin{lstlisting}[caption=The bootstrap routine common to nearly every C64\index{C64} program,escapechar=\%]
* = $0801
;-----------------------------------------------------------------
; Start program at CopyCodeToRAM (SYS 2064)
; SYS 2064 ($0810)
; This is where execution starts.
; It is a short BASIC program that executes whatever is at address
; $0810 (2064 in decimal). In this case, that's CopyCodeToRAM
;-----------------------------------------------------------------
  .BYTE $0B,$08          ; Points to EndOfProgram address below
  .BYTE $0A,$00          ; Arbitrary Line Number, in this case: 0010
  .BYTE $9E              ; SYS
  .BYTE $32,$30,$36,$34  ; 2064 ($810), which is CopyCodeToRAM below.
  .BYTE $00              ; Null byte to terminate the line above.
  .BYTE $00,$00          ; EndOfProgram  (all zeroes)
  .BYTE $00,$00,$00      ; Filler bytes so that InitializeProgram%\index{InitializeProgram}% is
                         ; located at $0810
\end{lstlisting}

\textbf{Lines 56-75. \icode{\textbf{CopyCodeToRam}}}
\begin{lstlisting}[caption=Some strictly unnecessary code copying,escapechar=\%]
RAM0835LoPtr                        = $FD
RAM0835HiPtr                        = $FE
RAM4000HiPtr                        = $FC
RAM4000LoPtr                        = $FB
;---------------------------------------------------
; CopyCodeToRAM
;----------------------------------------------------
CopyCodeToRAM
        LDA #$40
        STA RAM4000HiPtr
        LDA #$08
        STA RAM0835HiPtr
        LDA #$00
        STA RAM4000LoPtr
        LDA #$35
        STA RAM0835LoPtr
        LDY #$00                                 
        LDX #$06
CopyLoop   
        LDA (RAM0835LoPtr),Y
        STA (RAM4000LoPtr),Y
        DEY 
        BNE CopyLoop
        INC RAM4000HiPtr
        INC RAM0835HiPtr
        DEX 
        BNE CopyLoop

        JMP InitializeProgram%\index{InitializeProgram}%

\end{lstlisting}
\clearpage
\rhead[]{Launching the Game}
\textbf{Lines 46-50. \icode{\textbf{Sys2064}}:} Yay, let's do some admin like starting the program! All C64\index{C64} programs 
begin execution at position \icode{\$0801}, it's the law.
So every C64\index{C64} program has a little section like this that the C64\index{C64} executes first and which tells the C64\index{C64} what to do next.
Here we tell it to start execution at another location \icode{\$0810}. Since we're currently at location \icode{\$0801}, that's
almost 16 bytes ahead and contains the code we've labelled \icode{CopyCodeToRAM} which we jump to next.

The command is given in a slightly strange way. Not strange for the time, but an oddly convoluted convention in its own right.
The \icode{SYS} command is followed by the a series of PETSCII values forming the decimal number 2064. In hexadecimal this is
\icode{\$0810} which is the actual location to start executing. So \icode{SYS 2064} as given by \icode{\$9E \$32\$ 30 \$36,\$34}
means 'start executing whatever is at memory location \icode{\$0810}'. Which in this case is \icode{CopyCodeToRAM}.

The 'Abitrary Line Number', is just that: completely arbitrary. Here we have '0010', but in the commercial release of Psychedelia
the value chosen is \icode{\$C1,\$07} - translated to decimal this is '1985', the year of the game's release.

\bigskip
\bigskip
\textbf{Lines 56-75. \icode{\textbf{CopyCodeToRam}}:} Little Commodore 64 programs sure do like copying things around. This routine copies the entire code of the program to a
completely new position in memory at location \icode{\$4000} and then jumps to the routine \icode{InitializeProgram\index{InitializeProgram}} that will actually start running
'Psychedelia'.

I think this was some sort of cheap and dirty copy protection, designed to prevent people from casually disassembling the
program if they felt minded to do so. 

\clearpage
\textbf{Lines 82-113. \icode{\textbf{InitializeProgram\index{InitializeProgram}}}}
\begin{lstlisting}[caption=The initialization routine - visited only once\, at the very start of execution,escapechar=\%]
NUM_COLS  = $28
NUM_ROWS  = $18
COLOR_RAM = $D800
;-------------------------------------------------------
; InitializeProgram%\index{InitializeProgram}%
;-------------------------------------------------------
InitializeProgram%\index{InitializeProgram}%   
        LDA #BLACK
        STA $D020    ;Border Color
        STA $D021    ;Background Color 0

PrepareHiLoPtrs
        LDA #>COLOR_RAM
        STA colorRamHiPtr%\index{colorRamHiPtr}%
        LDA #<COLOR_RAM
        STA colorRamLoPtr%\index{colorRamLoPtr}%

        LDX #$00
FillLinePointerLoop
        LDA colorRamHiPtr%\index{colorRamHiPtr}%
        STA colorRAMLineTableHiPtrArray%\index{colorRAMLineTableHiPtrArray}%,X
        LDA colorRamLoPtr%\index{colorRamLoPtr}%
        STA colorRAMLineTableLoPtrArray%\index{colorRAMLineTableLoPtrArray}%,X
        CLC 
        ADC #NUM_COLS
        STA colorRamLoPtr%\index{colorRamLoPtr}%
        LDA colorRamHiPtr%\index{colorRamHiPtr}%
        ADC #$00
        STA colorRamHiPtr%\index{colorRamHiPtr}%
        INX 
        CPX #NUM_ROWS+1
        BNE FillLinePointerLoop

        JSR InitializeScreenAndText
        JMP LaunchPsychedelia%\index{LaunchPsychedelia}%

\end{lstlisting}
\clearpage

\rhead[]{\icode{InitializeProgram\index{InitializeProgram}}}
\textbf{Lines 82-113. \icode{\textbf{InitializeProgram\index{InitializeProgram}}}:} More admin!  First we set the background and border color to black by loading
\icode{\$00} to the memory locations \icode{\$D020} for the border and \icode{\$D021} for the background color.

\bigskip
\bigskip
\textbf{Lines 90-93. \icode{\textbf{PrepareHiLoPtrs}}:} \icode{COLOR\_RAM} (\icode{\$D800}) is the address at which Color RAM starts. Color
RAM is a region of memory 1000 bytes long that contains the color value for each of the 25 rows of 40 characters that get displayed on the
screen. 

In order to be able to work with this address we need to have a way of working with values that are two bytes long even though
our 6502 instruction set only accomodates single byte values. To do this we have to split the address in two and store each half in 
a separate variable. \icode{LDA \#>COLOR\_RAM} is an assembly language convention for referencing the first byte in the two byte address
\icode{COLOR\_RAM}, i.e \icode{\$D800}. So another way of writing it is simply: \icode{LDA \#\$D8}. Likewise \icode{LDA \#<COLOR\_RAM} is
another way of writing \icode{LDA \#\$00}. 

We're storing each of these values in \icode{colorRamHiPtr\index{colorRamHiPtr}} and \icode{colorRamLoPtr\index{colorRamLoPtr}} respectively
as we're going to use them to populate a pair of arrays with each half of the addresses of each of the 25 rows on the screen.


\bigskip
\bigskip
\textbf{Lines 101-113. \textbf{\icode{FillLinePointerLoop}}:} Here we set up the pair of arrays that Psychedelia will make heavy use of:
\icode{colorRAMLineTableHiPtrArray\index{colorRAMLineTableHiPtrArray}} and \icode{colorRAMLineTable\-LoPtrArray}.
Together these arrays will function as a map on to the screen for drawing our pixels. Since the Commodore 64 screen is 25 rows high we make each array
25 elements long and together each element in each array will combine to give the address on the screen for the start of each row.
\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=8cm,center}
      \begin{tabular}{cccc}
        \toprule
        Element &
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{HiPtrArray}} & 
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{LoPtrArray}} & 
        Address \\
        \midrule
0 & \icode{\$D8} & \icode{\$00} & \icode{\$D800} \\ 
1 & \icode{\$D8} & \icode{\$28} & \icode{\$D828} \\ 
. & . & . & .\\
6 & \icode{\$D8} & \icode{\$F0} & \icode{\$D8F0} \\ 
. & . & . & .\\
23 & \icode{\$DB} & \icode{\$70} & \icode{\$DB70} \\ 
24 & \icode{\$DB} & \icode{\$98} & \icode{\$DB98} \\ 
        \bottomrule
      \end{tabular}
    \end{adjustbox}
  }\caption{Our two arrays and their contents - each combining to give us an address for the start of each row in Color RAM. }
\end{figure}

So in practice what this gives us is a 'single array' with which we can address each row on the screen and write color values
to the pixel position of our choice.

\input{listing_commentary/screen_table}

For example, to make the pixel on row 7 and column 15 red above, we have written a value of \icode{02} to the address \icode{\$D8FF}. This 
address is
formed from adding \icode{\$D8F0} (the 7th element in our array) + 15, i.e. \icode{\$D8F0} + \icode{\$0F} = \icode{\$D8FF}. 
To actually do this we would do something like the following:
 
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,escapechar=\%]
    RED = $02
    ; Load the 7th element from each array.
    LDX #$06
    ; This stores $F0 in currentLineInColorRamLoPtr
    LDA colorRAMLineTableLoPtrArray%\index{colorRAMLineTableLoPtrArray}%,X
    STA currentLineInColorRamLoPtr
    ; This stores $D8 in currentLineInColorRamHiPtr
    LDA colorRAMLineTableHiPtrArray%\index{colorRAMLineTableHiPtrArray}%,X
    STA currentLineInColorRamHiPtr
    ; Load $02, i.e. RED, to the Accumulator. 
    LDA #RED
    ; Y will be our index so give it the offset into the
    ; line, i.e. 15. 
    LDY #$0F
    ; Write $02 to address $DBFF, painting it red.
    STA (currentLineInColorRamLoPtr),Y
\end{lstlisting}

This gives us an idea of how the array will be used, but let's remind ourselves that all we are doing here is setting
it up in the first place. This consists of iterating from 0 to 24 and populating each element in our two arrays with
the appropriate value for the line on the screen each element represents. So at each iteration we store
the current values into the current position in the array given by \icode{X}:

\begin{lstlisting}[escapechar=\%]
FillLinePointerLoop
        LDA colorRamHiPtr%\index{colorRamHiPtr}%
        STA colorRAMLineTableHiPtrArray%\index{colorRAMLineTableHiPtrArray}%,X
        LDA colorRamLoPtr%\index{colorRamLoPtr}%
        STA colorRAMLineTableLoPtrArray%\index{colorRAMLineTableLoPtrArray}%,X
\end{lstlisting}

Then we add  \icode{NUM\_COLS} (i.e. 40) to \icode{colorRamLoPtr\index{colorRamLoPtr}}: 

\begin{lstlisting}[escapechar=\%]
        CLC 
        ADC #NUM_COLS
        STA colorRamLoPtr%\index{colorRamLoPtr}%
\end{lstlisting}

Finally we use \icode{ADC \$00} to ensure any carry from the previous addition is added to \icode{colorRamHiPtr\index{colorRamHiPtr}}. 

\begin{lstlisting}[escapechar=\%]
        LDA colorRamHiPtr%\index{colorRamHiPtr}%
        ADC #$00
        STA colorRamHiPtr%\index{colorRamHiPtr}%
\end{lstlisting}

This succesfully increments both \icode{colorRamLoPtr\index{colorRamLoPtr}} and \icode{colorRamHiPtr\index{colorRamHiPtr}} for storage in the next position in
the array. Finally the loop will stop when \icode{X} eventually reaches \icode{NUM\_ROWS} + 1, that is, once we have
populated an element in the array for every row:

\begin{lstlisting}[escapechar=\%]
        INX 
        CPX #NUM_ROWS+1
        BNE FillLinePointerLoop
\end{lstlisting}
%\input{listing_commentary/titlescreen_color_ram_stripes}

\clearpage
\textbf{Lines 715-725. \icode{\textbf{InitializeScreenAndText}}}
\begin{lstlisting}[caption = A routine that fills the screen with black and the title text.,escapechar=\%]
bannerText   
        .TEXT $00,"PSYCHEDELIA...A FORETASTE BY JEFF MINTER"

;-------------------------------------------------------
; InitializeScreenAndText
;-------------------------------------------------------
InitializeScreenAndText   
        JSR InitializeScreen

        LDX #NUM_COLS
b452D   LDA bannerText,X
        STA SCREEN_RAM + $03BF,X
        LDA #WHITE
        STA COLOR_RAM + $03BF,X
        DEX 
        BNE b452D
        RTS 
\end{lstlisting}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 118-132. \icode{\textbf{InitializeScreen}}}
\begin{lstlisting}[caption = Fills the screen with black,escapechar=\%]
;-------------------------------------------------------
; InitializeScreen
;-------------------------------------------------------
InitializeScreen   
        LDX #$00
b4034   LDA #$CF
        STA SCREEN_RAM + $0000,X
        STA SCREEN_RAM + $0100,X
        STA SCREEN_RAM + $0200,X
        STA SCREEN_RAM + $0300,X
        LDA #BLACK
        STA COLOR_RAM + $0000,X
        STA COLOR_RAM + $0100,X
        STA COLOR_RAM + $0200,X
        STA COLOR_RAM + $0300,X
        DEX 
        BNE b4034
        RTS 

\end{lstlisting}
\clearpage

\rhead[]{\icode{InitializeScreenAndText}}
\textbf{Lines 715-725. \icode{\textbf{InitializeScreenAndText}}:} Populates the screen with the banner text. The same loop writes
the text (contained in \icode{bannerText}) to the Screen RAM and sets the color of each character to white by writing the
value \icode{\$0C} (White) to the Color RAM.

\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/foretaste.png}
  \caption*{The screen after \icode{InitializeScreenAndText} has worked its magic.}
\end{figure}

\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 118-132. \icode{\textbf{InitializeScreen}}:} This fills the screen with black boxes. These are the boxes we will color in each time we paint a pixel.
As mentioned before there are two components to writing a character to a screen. The first is the character
itself, the second is the color(s) of the character. Psychedelia works by drawing the same character at every
position but painting it black if its empty or filling it with color if it should be displayed. So when
we initialize the screen we paint a box at every position and paint it black.

\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/black.png}
  \caption*{The screen after \icode{InitializeScreen} has painted it black.}
\end{figure}

\clearpage
\textbf{Lines 300-313. \icode{\textbf{starOneXPosArray\index{starOneXPosArray}}}}
\begin{lstlisting}[caption = Hopefully this looks familiar.,escapechar=\%]
starOneXPosArray%\index{starOneXPosArray}%
  .BYTE $00,$01,$01,$01,$00,$FF,$FF,$FF,$55       ;        5       
  .BYTE $00,$02,$00,$FE,$55                       ;                
  .BYTE $00,$03,$00,$FD,$55                       ;       4 4      
  .BYTE $00,$04,$00,$FC,$55                       ;        3       
  .BYTE $FF,$01,$05,$05,$01,$FF,$FB,$FB,$55       ;        2       
  .BYTE $00,$07,$00,$F9,$55                       ;        1       
  .BYTE $55                                       ;   4   000   4  
starOneYPosArray%\index{starOneYPosArray}%
  .BYTE $FF,$FF,$00,$01,$01,$01,$00,$FF,$55       ; 5  3210 0123  5
  .BYTE $FE,$00,$02,$00,$55                       ;   4   000   4  
  .BYTE $FD,$00,$03,$00,$55                       ;        1       
  .BYTE $FC,$00,$04,$00,$55                       ;        2       
  .BYTE $FB,$FB,$FF,$01,$05,$05,$01,$FF,$55       ;        3       
  .BYTE $F9,$00,$07,$00,$55                       ;       4 4      
  .BYTE $55                                       ;                
                                                  ;        5       
\end{lstlisting}

\textbf{Lines 321-327. \icode{\textbf{PutRandomByteInAccumulator\index{PutRandomByteInAccumulator}}}}
\begin{lstlisting}[caption= Random\, unused\, feels like a metaphor.,escapechar=\%]
randomByteAddress=$414E
;-------------------------------------------------------
; PutRandomByteInAccumulator%\index{PutRandomByteInAccumulator}%
;-------------------------------------------------------
PutRandomByteInAccumulator%\index{PutRandomByteInAccumulator}%   
        LDA $E199,X
        INC randomByteAddress
        RTS 
\end{lstlisting}
\textbf{Lines 434-445. \icode{\textbf{ReinitializeSequences\index{ReinitializeSequences}}}}
\begin{lstlisting}[caption = Fill our pixel arrays with zeros.,escapechar=\%]
;-------------------------------------------------------
; ReinitializeSequences%\index{ReinitializeSequences}%
;-------------------------------------------------------
ReinitializeSequences%\index{ReinitializeSequences}%   
        LDX #$00
        TXA 
ReinitializeLoop   
        STA pixelXPositionArray%\index{pixelXPositionArray}%,X
        STA pixelYPositionArray%\index{pixelYPositionArray}%,X
        STA currentColorIndexArray%\index{currentColorIndexArray}%,X
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X
        INX 
        CPX #$40
        BNE ReinitializeLoop
        RTS 

\end{lstlisting}
\clearpage

\rhead[]{\icode{starOneXPosArray\index{starOneXPosArray}/starOneYPosArray\index{starOneYPosArray}}}
\textbf{Lines 300-313. \icode{\textbf{starOneXPosArray\index{starOneXPosArray}}}:} We've encountered this data structure in previous chapters. It encodes the pattern used in the listing.
Psychedelia itself uses many different patterns and we explore these in detail in
\hyperref[sec:patterns]{\textcolor{blue}{our chapter on Patterns.}} 

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 321-327. \icode{\textbf{PutRandomByteInAccumulator\index{PutRandomByteInAccumulator}}}:} This routine is unused in the listing, but is used by the commercial version of 'Psychedelia'. This is
presumably a product of taking the commercial source code and reducing it down for the listing but 
leaving this in by accident.

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\textbf{Lines 434-445. \icode{\textbf{ReinitializeSequences\index{ReinitializeSequences}}}:} This is a loop that fills the 5 arrays defined on the next page with zeroes.
\icode{TXA} loads the value of \icode{\$00} previously loaded to \icode{X} to the \icode{A} register, so it could as easily be \icode{LDA \$00}
however it has the dubious advantage of being one byte shorter as an instruction.

Notice that \icode{X} gets incremented on each pass of the loop until it reaches \icode{\$40} - filling all 64 elements of each array with
\icode{\$00}.
\clearpage
\textbf{Lines 385-429. \icode{\textbf{pixelXPositionArray\index{pixelXPositionArray}}}}
\begin{lstlisting}[escapechar=\%][caption = The pixel buffers\, each 64 bytes long though only 32 bytes are used in this version thanks to \icode{MAX\_INDEX\_VALUE}[escapechar=\%]
being set to \icode{\$1F} (32).]
countToMatchCurrentIndex%\index{countToMatchCurrentIndex}%      .BYTE $01
MAX_INDEX_VALUE               .BYTE $1F
pixelXPositionArray%\index{pixelXPositionArray}%   
        .BYTE $0F,$0E,$0D,$0C,$0B,$0A,$09,$04
        .BYTE $05,$06,$07,$08,$09,$0A,$0B,$0C
        .BYTE $0D,$0E,$0F,$10,$11,$12,$13,$14
        .BYTE $15,$16,$17,$14,$13,$12,$11,$10
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
pixelYPositionArray%\index{pixelYPositionArray}%   
        .BYTE $0C,$0D,$0E,$0F,$0F,$0F,$0E,$04
        .BYTE $04,$04,$04,$04,$04,$04,$04,$05
        .BYTE $06,$07,$08,$09,$0A,$0B,$0C,$0D
        .BYTE $0D,$0D,$0D,$07,$09,$09,$0A,$0B
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
currentColorIndexArray%\index{currentColorIndexArray}%   
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
initialSmoothingDelayForStep   
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $0C,$0C,$0C,$0C,$0C,$0C,$0C,$0C
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
smoothingDelayForStep   
        .BYTE $04,$07,$01,$02,$03,$06,$07,$06
        .BYTE $0C,$02,$03,$06,$07,$01,$02,$02
        .BYTE $04,$04,$07,$01,$02,$03,$06,$07
        .BYTE $0C,$02,$03,$02,$03,$07,$01,$02
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00
        .BYTE $00,$00,$00,$00,$00,$00,$00,$00


\end{lstlisting}
\clearpage

\rhead[]{Buffer Arrays}
\textbf{Lines 385-429. \icode{\textbf{pixelXPositionArray\index{pixelXPositionArray}}}:} Five arrays of 64 bytes each, though only the first 32 in each are actually used. This fact is determined
by the value of \icode{\$1F} (32) in \icode{MAX\_INDEX\_VALUE}. We see this being enforced on the next page in
\icode{MainPaintLoop\index{MainPaintLoop}}. Defining 64 bytes, but only using 32 in the end, suggests Minter\index{Minter} had to play around
with the performance limitations of the C64\index{C64}. Since each byte represents a pattern that must be drawn and painted
at a given position in the screen, using all 64 by setting allocated \icode{MAX\_INDEX\_VALUE} to \icode{\$3F} 
was not necessarily prohibitive but certainly resulted in a more sluggish effect.

We've seen the first three arrays in use already when we looked at the core
pattern painting routine. Each byte in the array refers to a distinct step in the paint sequence.
\icode{pixelXPositionArray\index{pixelXPositionArray}} and \icode{pixelYPositionArray\index{pixelYPositionArray}} together define a location on the screen
that is treated as the origin for painting and drawing an instance of the current pattern. So for example \icode{\$0F,\$0C} given by the
first byte in each represents column 16 (\icode{\$0F}) and row 14 (\icode{\$0C}). The value in
the corresponding position of \icode{currentColorIndexArray\index{currentColorIndexArray}} represents the color to 'start from'.


\clearpage
\textbf{Lines 450-482. \icode{\textbf{LaunchPsychedelia\index{LaunchPsychedelia}}}}
\begin{lstlisting}[caption= The game's main loop.,escapechar=\%]
;-------------------------------------------------------
; LaunchPsychedelia%\index{LaunchPsychedelia}%
;-------------------------------------------------------
LaunchPsychedelia%\index{LaunchPsychedelia}%   
        JSR ReinitializeSequences%\index{ReinitializeSequences}%
        JSR SetUpIntteruptHandler

MainPaintLoop%\index{MainPaintLoop}%   
        ; Part 1: Check if it's time to paint.
        INC currentPositionInArrays
        LDA currentPositionInArrays
        AND MAX_INDEX_VALUE
        STA currentPositionInArrays
        TAX 
        DEC smoothingDelayForStep,X
        BNE GoBackToStartOfLoop

        ; Part 2: Check if there's a color to paint.
        LDA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X

        LDA currentColorIndexArray%\index{currentColorIndexArray}%,X
        CMP #$FF
        BEQ GoBackToStartOfLoop

        ; Part 3: Actually do a paint.
ActuallyDoAPaint
        STA currentValueInColorIndexArray%\index{currentValueInColorIndexArray}%
        LDA pixelXPositionArray%\index{pixelXPositionArray}%,X
        STA pixelXPosition%\index{pixelXPosition}%
        LDA pixelYPositionArray%\index{pixelYPositionArray}%,X
        STA pixelYPosition%\index{pixelYPosition}%

        JSR PaintStructureAtCurrentPosition%\index{PaintStructureAtCurrentPosition}%

        LDX currentPositionInArrays
        DEC currentColorIndexArray%\index{currentColorIndexArray}%,X

GoBackToStartOfLoop   
        JMP MainPaintLoop%\index{MainPaintLoop}%

\end{lstlisting}

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
        \midrule
        \$20 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
        \$1F & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$20 and \$1F gives \$00, ensuring we always loop between 0 and 32.}
\end{figure}
\clearpage
\rhead[]{\icode{LaunchPsychedelia\index{LaunchPsychedelia}}}
\textbf{Lines 450-482. \icode{\textbf{LaunchPsychedelia\index{LaunchPsychedelia}}}:} Finally a routine that resembles getting down to business. We start by initializing the arrays we saw on the 
previous page to all zeros in \icode{ReinitializeSequences\index{ReinitializeSequences}}. Next we set up the interrupt handler, which will
be responsible for processing user input. We'll take a look at this routine in more detail later on.

For now, what follows is the game's core loop. This runs forever, round and round, repeating all the steps between the
\icode{MainPaintLoop\index{MainPaintLoop}} and \icode{GoBackToStartOfLoop} labels. 

There are three parts to the code inside this loop. 

The first is visited on every journey through the loop and increments the
value stored in \icode{currentPositionInArrays}. It keeps this value looping between 0 and 32 by always \icode{AND}'ing
it with \icode{MAX\_INDEX\_VALUE}. This \icode{AND} operation ensures that once it reaches 33, for example, the result
goes back to zero. (See opposite page.)

Now that it has a new value in \icode{currentPositionInArrays} it transfers it to the \icode{X} register and uses the 
\icode{X} as in index into the \icode{smoothingDelayForStep} array (and all the other arrays) which we saw defined on the previous 
page. It decrements the byte at this index in the \icode{smoothingDelayForStep} array and if it has reached zero
proceeds to Part 2 of the loop, otherwise it jumps execution to \icode{GoBackToStartOfLoop}, which itself jumps execution
back to the top again at \icode{MainPaintLoop\index{MainPaintLoop}}. Back on the merry-go-round we go.

If we get to Part 2 this time round we first reset the value in the \icode{framesRemaining\-ToNextPaintForStep} array with an initial value for it kept in the corresponding
location of \icode{initialFramesRemaining\-ToNextPaintForStep}. We next check if we've run out of colors to paint for this step
in the sequence: if the value at the index position in \icode{currentColorIndexArray\index{currentColorIndexArray}} has already reached \icode{\$FF} (because
it was decremented below zero and so cycled back to \icode{\$FF}) then there's nothing to paint and we jump back to the top
again via \icode{GoBackToStartOfLoop}. No colors means no painting after all!

If there actually, finally, is something to do for this position in the sequence we can pass to Part 3. Here we load up the X and Y
position to use from our \icode{pixelXPositionArray\index{pixelXPositionArray}} and \icode{pixelYPositionArray\index{pixelYPositionArray}} and do the actual painting work we covered
in our previous chapter, all of which happens in \icode{PaintStructureAtCurrentPosition\index{PaintStructureAtCurrentPosition}}. As we saw this routine is the top of the
tree for the pixel painting routines in Psychedelia, and all it needed from us here was an X and Y position as well as a color
loaded from the \icode{currentColorIndexArray\index{currentColorIndexArray}}. Equipped with that it can paint anything. 

\clearpage
\textbf{Lines 217-285. \icode{\textbf{PaintStructureAtCurrentPosition\index{PaintStructureAtCurrentPosition}}}}
\begin{lstlisting}[caption = The routine responsible for orchestrating the pattern painting.,escapechar=\%]
NUM_ARRAYS = $07
;-------------------------------------------------------
; PaintStructureAtCurrentPosition%\index{PaintStructureAtCurrentPosition}%
;-------------------------------------------------------
PaintStructureAtCurrentPosition%\index{PaintStructureAtCurrentPosition}%   
        JSR PaintPixelForCurrentSymmetry%\index{PaintPixelForCurrentSymmetry}%

        LDY #$00
        LDA currentValueInColorIndexArray%\index{currentValueInColorIndexArray}%
        CMP #NUM_ARRAYS
        BNE CanLoopAndPaint
        RTS 

CanLoopAndPaint   
        LDA #NUM_ARRAYS
        STA countToMatchCurrentIndex%\index{countToMatchCurrentIndex}%
       
        LDA pixelXPosition%\index{pixelXPosition}%
        STA initialPixelXPosition
        LDA pixelYPosition%\index{pixelYPosition}%
        STA initialPixelYPosition

LineReadLoop   
        ; See next page for the contents of this loop.
        JMP LineReadLoop

RestorePositionsAndReturn%\index{RestorePositionsAndReturn}%   
        LDA initialPixelXPosition
        STA pixelXPosition%\index{pixelXPosition}%
        LDA initialPixelYPosition
        STA pixelYPosition%\index{pixelYPosition}%
        RTS 

\end{lstlisting}
\clearpage

\rhead[]{\icode{PaintStructureAtCurrentPosition\index{PaintStructureAtCurrentPosition}}}
\textbf{Lines 217-285. \icode{\textbf{PaintStructureAtCurrentPosition\index{PaintStructureAtCurrentPosition}}}:} To understand how this routine and the ones it calls on the subsequent pages hang together you should refer
back to the previous chapter. Here we will limit ourselves to explaining some of the detailed points of the
code.

The meat of this routine occurs in the \icode{LineReadLoop} section on the next page but here we can see the
gatekeeping and bookkeeping activities of the code before and after that central section. 

The first call to \icode{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}} paints a pixel at the current position given by 
\icode{pixelXPosition\index{pixelXPosition}} and \icode{pixelYPosition\index{pixelYPosition}}. The \icode{-CurrentSymmetry} part ensures that extra
pixels are projected along the axes given by the current symmetry setting. In our listing this is the
X-axis, ensuring we always paint two patterns. We'll look at this in a little more detail later.

Next we figure out if we should just return early from this routine and do nothing further. This will be the
case if \icode{currentValueInColorIndexArray\index{currentValueInColorIndexArray}} is still at the same value as \icode{NUM\_ARRAYS} (7). If it is
we return from the routine straight away (\icode{RTS}) and
\icode{MainPaintLoop\index{MainPaintLoop}} will decrement it the next time around for this position
in the sequence and we can paint an actual color.

You cans see that before and after the \icode{LineReadLoop} section we're storing the values in \icode{pixelX/YPosition} in
\icode{initialPixelX/YPosition} and then restoring them when the loop is over. This is because \icode{LineReadLoop}
will frequently overwrite the values as it iterates through the positions given in the pattern array \icode{starOneX/YPosArray}.

\clearpage
\textbf{Lines 239-278. \icode{\textbf{LineReadLoop}}}
\begin{lstlisting}[caption=The core pattern-painting loop.,escapechar=\%]
LineReadLoop   
        LDA initialPixelXPosition
        CLC 
        ADC starOneXPosArray%\index{starOneXPosArray}%,Y
        STA pixelXPosition%\index{pixelXPosition}%

        LDA initialPixelYPosition
        CLC 
        ADC starOneYPosArray%\index{starOneYPosArray}%,Y
        STA pixelYPosition%\index{pixelYPosition}%

        TYA 
        PHA 

        JSR PaintPixelForCurrentSymmetry%\index{PaintPixelForCurrentSymmetry}%

        PLA 
        TAY 
        INY 

        LDA starOneXPosArray%\index{starOneXPosArray}%,Y
        CMP #$55
        BNE LineReadLoop

        DEC countToMatchCurrentIndex%\index{countToMatchCurrentIndex}%
        LDA countToMatchCurrentIndex%\index{countToMatchCurrentIndex}%
        CMP currentValueInColorIndexArray%\index{currentValueInColorIndexArray}%
        BEQ RestorePositionsAndReturn%\index{RestorePositionsAndReturn}%
        CMP #$01
        BEQ RestorePositionsAndReturn%\index{RestorePositionsAndReturn}%

        INY 
        JMP LineReadLoop

\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny,escapechar=\%]
starOneXPosArray%\index{starOneXPosArray}%
  .BYTE $00,$01,$01,$01,$00,$FF,$FF,$FF,$55       ;        5       
  .BYTE $00,$02,$00,$FE,$55                       ;                
  .BYTE $00,$03,$00,$FD,$55                       ;       4 4      
  .BYTE $00,$04,$00,$FC,$55                       ;        3       
  .BYTE $FF,$01,$05,$05,$01,$FF,$FB,$FB,$55       ;        2       
  .BYTE $00,$07,$00,$F9,$55                       ;        1       
  .BYTE $55                                       ;   4   000   4  
starOneYPosArray%\index{starOneYPosArray}%
  .BYTE $FF,$FF,$00,$01,$01,$01,$00,$FF,$55       ; 5  3210 0123  5
  .BYTE $FE,$00,$02,$00,$55                       ;   4   000   4  
  .BYTE $FD,$00,$03,$00,$55                       ;        1       
  .BYTE $FC,$00,$04,$00,$55                       ;        2       
  .BYTE $FB,$FB,$FF,$01,$05,$05,$01,$FF,$55       ;        3       
  .BYTE $F9,$00,$07,$00,$55                       ;       4 4      
  .BYTE $55                                       ;                
                                                  ;        5       
\end{lstlisting}
\clearpage

\rhead[]{\icode{PaintStructureAtCurrentPosition\index{PaintStructureAtCurrentPosition}: LineReadLoop}}
\textbf{Lines 239-278. \icode{\textbf{LineReadLoop}}:} A better name for this loop might be \icode{ThisIsWhereThe\-PsychedeliaHappens}. As I keep saying, we unpicked the mechanics
of the \icode{Paint\-StructureAtCurrentPosition} routine that this loop is a part of in the previous chapter so if you didn't understand my explanation there (definitely my doing if you didn't)
then I'm not sure I can do anything to retrieve the situation here.

So instead let's look at the detail of what's going on in the loop. \icode{Y} starts out at zero and gets incremented at
each pass through the loop. So the first paragraph adds the value at index 0 in \icode{starOneXPosArray\index{starOneXPosArray}} in this pass to \icode{initialPixelXPosition}
and stores it in \icode{pixelXPosition\index{pixelXPosition}}. That value is \icode{\$00}, on the next it will be \icode{\$01}, on the pass after that
it will be \icode{\$01} again. You can hopefully see how the \icode{LDA}, \icode{ADC}, and \icode{STA} instructions are doing that
but you might wonder what the \icode{CLC} is about. This clears the CPU's 'Carry Bit' so that the addition performed by \icode{ADC}
doesn't inadvertently include any carries from previous addition operations in its result.

The next paragraph does the same for \icode{pixelYPosition\index{pixelYPosition}} using the \icode{starOneXPosArray\index{starOneXPosArray}} array. But the paragraph after
that does something that requires explanation. It transfers the current value in the \icode{Y} register to the \icode{A} register
using the instruction \icode{TYA}. Then it pushes the \icode{A} register on to a thing called the 'Stack' using the instruction
\icode{PHA}. The 'Stack' is a stack of values that resembles a stack of plates: you add things to the top of it and take things
from the top of it. So when you take something from the stack using the complementary instruction \icode{PLA} you are taking
what was last put there (and not pulled off it before you).

So the \icode{TYA, PHA, PLA, TAY} sequence of instructions that surrounds our call to \icode{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}} has the
simple effect of ensuring that we keep our current value of \icode{Y} unmolested by whatever \icode{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}}
gets up to, because that can (and does) include populating and using the \icode{Y} register for other stuff. As you can imagine
this is a common technique in a CPU where there are only three free variables to play with (\icode{X,Y,A}) and you have more than three things
to worry about!

Next, after incrementing \icode{Y} (\icode{INY}) we check the next value in \icode{starOneXPosArray\index{starOneXPosArray}}. If it's \icode{\$55} then
we've reached the end of a line the pattern and must check whether we've read all the lines in the pattern we need to for this
round. If we have, then we return by calling \icode{RestorePositionsAndReturn\index{RestorePositionsAndReturn}}, otherwise we increment \icode{Y} again to read
in the first value of the next line and continue looping.

\clearpage
\textbf{Lines 332-382. \icode{\textbf{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}}}}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,caption=Choosing what to paint based on the current symmetry setting.,escapechar=\%]
currentSymmetrySettingForStep%\index{currentSymmetrySettingForStep}%   .BYTE $01
;-------------------------------------------------------
; PaintPixelForCurrentSymmetry%\index{PaintPixelForCurrentSymmetry}%
;-------------------------------------------------------
PaintPixelForCurrentSymmetry%\index{PaintPixelForCurrentSymmetry}%   
        ; First paint the normal pattern without any
        ; symmetry.
        LDA pixelXPosition%\index{pixelXPosition}%
        PHA 
        LDA pixelYPosition%\index{pixelYPosition}%
        PHA 
        JSR PaintPixel%\index{PaintPixel}%

        LDA currentSymmetrySettingForStep%\index{currentSymmetrySettingForStep}%
        BNE HasSymmetry

CleanUpAndReturnFromSymmetry   
        PLA 
        STA pixelYPosition%\index{pixelYPosition}%
        PLA 
        STA pixelXPosition%\index{pixelXPosition}%
        RTS 

HasSymmetry   
        ; Has a pattern to paint on the X axis
        ; symmetry so prepare for that.
        LDA #NUM_COLS
        SEC 
        SBC pixelXPosition%\index{pixelXPosition}%
        STA pixelXPosition%\index{pixelXPosition}%

        JSR PaintPixel%\index{PaintPixel}%

        LDA currentSymmetrySettingForStep%\index{currentSymmetrySettingForStep}%
        CMP #$01
        BEQ CleanUpAndReturnFromSymmetry

        LDA #NUM_ROWS
        SEC 
        SBC pixelYPosition%\index{pixelYPosition}%
        STA pixelYPosition%\index{pixelYPosition}%
        JSR PaintPixel%\index{PaintPixel}%

        PLA 
        TAY 
        PLA 
        STA pixelXPosition%\index{pixelXPosition}%
        TYA 
        PHA 
        JSR PaintPixel%\index{PaintPixel}%
        PLA 
        STA pixelYPosition%\index{pixelYPosition}%
        RTS 

\end{lstlisting}
\clearpage

\rhead[]{\icode{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}}}
\textbf{Lines 332-382. \icode{\textbf{PaintPixelForCurrentSymmetry\index{PaintPixelForCurrentSymmetry}}}:} This routine is concerned entirely with setting up the values of \icode{pixelXPosition\index{pixelXPosition}} and \icode{pixelYPosition\index{pixelYPosition}} correctly
for calling the routine \icode{PaintPixel\index{PaintPixel}}. The reason this is necessary is that the commercial version of Psychedelia
has up to 4 different arrangements or 'symmetries' for painting the chosen pattern. The simplest arrangement is just to 
paint one copy of the pattern and be done. The first paragraph here takes care of that, no matter what arrangement we're
painting we're always painting the pattern at least once. 

While the commercial version has at least three others to worry about, and offers the user a way of switching between each,
the listing edition hard-codes a single behaviour of always painting the pattern twice, reflected on the X-axis in a kind of mirror
arrangement. This behaviour is defined by the value in \icode{currentSymmetrySettingForStep\index{currentSymmetrySettingForStep}} and as we can see opposite it
is hard-coded to \icode{\$01}. Because it is set to a non-zero value, \icode{BNE HasSymmetry} always returns true and execution
jumps to \icode{HasSymmetry}.

\icode{HasSymmetry} calculates the reflected position on the X-axis for the pattern by simply subtracting the current value
of \icode{pixelXPosition\index{pixelXPosition}} from the total number of columns in the screen (which is 40). This has the neat effect of ensuring
the reflected position is always exactly opposite to the original pattern.

The paragraph after \icode{PaintPixel\index{PaintPixel}} always returns from the routine because as we saw \icode{currentSymmetrySettingForStep\index{currentSymmetrySettingForStep}} is
hardcoded to \icode{\$01}. So the code after it is never executed and is redundant here. What it does is draw a full four-pattern
arrangement with reflections along the X and Y axes. If we set \icode{currentSymmetrySettingForStep\index{currentSymmetrySettingForStep}} to \icode{\$02} and run the
listing we can see this in action.


\begin{figure}[H]
    \centering
      \includegraphics[height=5cm]{src/listing_commentary/four_pattern.png}
  \caption*{The display with \icode{currentSymmetrySettingForStep\index{currentSymmetrySettingForStep}} set to \icode{\$02}}
\end{figure}


\clearpage
\textbf{Lines 164-214. \icode{\textbf{PaintPixel\index{PaintPixel}}}}
\begin{lstlisting}[caption=Where the painting is actually done.,escapechar=\%]
presetColorValuesArray%\index{presetColorValuesArray}%
;         0    6    2    4      5    3     7      1
  .BYTE BLACK,BLUE,RED,PURPLE,GREEN,CYAN,YELLOW,WHITE
;-------------------------------------------------------
; PaintPixel%\index{PaintPixel}%
;-------------------------------------------------------
PaintPixel%\index{PaintPixel}%   
        LDA pixelXPosition%\index{pixelXPosition}%
        AND #$80 ; Detect if has moved off left of screen
        BNE ReturnEarly
        LDA pixelXPosition%\index{pixelXPosition}%
        CMP #NUM_COLS
        BPL ReturnEarly
        LDA pixelYPosition%\index{pixelYPosition}%
        AND #$80 ; Detect if has moved off top of screen.
        BNE ReturnEarly
        LDA pixelYPosition%\index{pixelYPosition}%
        CMP #NUM_ROWS
        BPL ReturnEarly

        JSR LoadXAndYPosition%\index{LoadXAndYPosition}%
        LDA (currentLineForPixelInColorRamLoPtr),Y
        AND #COLOR_MAX

        LDX #$00
CheckPresetsLoop   
        CMP presetColorValuesArray%\index{presetColorValuesArray}%,X
        BEQ MaybePaintPixel
        INX 
        CPX #COLOR_MAX + 1
        BNE CheckPresetsLoop

MaybePaintPixel   
        TXA 
        STA indexOfCurrentColor%\index{indexOfCurrentColor}%
        LDX currentValueInColorIndexArray%\index{currentValueInColorIndexArray}%
        INX 
        CPX indexOfCurrentColor%\index{indexOfCurrentColor}%
        BEQ ActuallyPaintPixel%\index{ActuallyPaintPixel}%
        BPL ActuallyPaintPixel%\index{ActuallyPaintPixel}%
        RTS 

ActuallyPaintPixel%\index{ActuallyPaintPixel}%   
        LDX currentValueInColorIndexArray%\index{currentValueInColorIndexArray}%
        LDA presetColorValuesArray%\index{presetColorValuesArray}%,X
        STA (currentLineForPixelInColorRamLoPtr),Y
        RTS 
\end{lstlisting}
\clearpage

\rhead[]{\icode{PaintPixel\index{PaintPixel}}}
\textbf{Lines 164-214. \icode{\textbf{PaintPixel\index{PaintPixel}}}:} The first paragraph searches for a reason to \icode{ReturnEarly}. The first
check, whether the pixel has moved beyond the leftmost position on the screen, is a good example of how assembly language involves
logic that might be unintuitive at first. In layman's terms we just want to ask is \icode{pixelXPosition\index{pixelXPosition}} less than zero. One neat
way of doing this in our situation is to check if decrementing past \icode{\$00} has resulted in a value of \icode{\$FF}. Since
the rightmost position never exceeds \icode{\$40} this means we can just check if the leftmost bit on the value is set or not: if 
it is then we've gone below zero. So an \icode{AND \$80} check will do the job - if it returns true then we've gone below zero:

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
        \midrule
        \$FF & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
        \$80 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \midrule
        Result & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$FF and \$80 gives \$80, a non-zero value - so the \icode{AND} returns true.}
\end{figure}

If we get past these checks we can prepare ourselves for writing to the screen by calling \icode{LoadXAndYPosition\index{LoadXAndYPosition}}. As we can
see below this loads the \icode{Y} position to the \icode{X} register and the \icode{X} position to the \icode{Y} register. There
is a reason that this is what seems like the wrong way round - the use we intend to make of each register is constrained by the
rules of assembly language.

\begin{lstlisting}[escapechar=\%]
LoadXAndYPosition%\index{LoadXAndYPosition}%   
        LDX pixelYPosition%\index{pixelYPosition}%
        LDA colorRAMLineTableLoPtrArray%\index{colorRAMLineTableLoPtrArray}%,X
        STA currentLineForPixelInColorRamLoPtr
        LDA colorRAMLineTableHiPtrArray%\index{colorRAMLineTableHiPtrArray}%,X
        STA currentLineForPixelInColorRamHiPtr
        LDY pixelXPosition%\index{pixelXPosition}%
        RTS 
\end{lstlisting}

\textbf{Lines 210-214. \icode{\textbf{ActuallyPaintPixel\index{ActuallyPaintPixel}}}:} This is the rubber hitting the road. We're writing data to the
screen. Recall that our  \icode{colorRAMLineTableLoPtrArray\index{colorRAMLineTableLoPtrArray}} array is an array of 25 screen addresses each one pointing
to the start of a row. In \icode{LoadXAndYPosition\index{LoadXAndYPosition}} we have set up \icode{currentLineForPixelInColorRamLoPtr} and \icode{currentLine\-ForPixelInColorRamHiPtr} to contain the address of the pixel we want to paint. So for example if the address of Color RAM we want to populate
is \icode{\$D810} then \icode{currentLineForPixelInColorRamLoPtr} will contain \icode{\$10} and \icode{currentLine\-ForPixelInColorRamHiPtr} will
contain \icode{\$D8}. 
\clearpage
\textbf{Lines 491-506. \icode{\textbf{SetUpInterruptHandler}}}
\begin{lstlisting}[caption= Setting up our Interrupt Handler,escapechar=\%]
SetUpIntteruptHandler   
        SEI 
        LDA #<MainInterruptHandler
        STA $0314    ;IRQ
        LDA #>MainInterruptHandler
        STA $0315    ;IRQ

        LDA #$0A
        STA cursorXPosition%\index{cursorXPosition}%
        STA cursorYPosition%\index{cursorYPosition}%

        LDA #$01
        STA $D015    ;Sprite display Enable
        STA $D027    ;Sprite 0 Color
        CLI 
        RTS 
\end{lstlisting}
\clearpage
\rhead[]{\icode{SetUpInterruptHandler}}
\textbf{Lines 491-506. \icode{\textbf{SetUpInterruptHandler}}:} What is an Interrupt Handler when it's at home and why are
we setting one up?

Recall that this routine was called immediately before we entered the main loop. It is only ever called once:
\begin{lstlisting}[escapechar=\%]
LaunchPsychedelia%\index{LaunchPsychedelia}%   
        JSR ReinitializeSequences%\index{ReinitializeSequences}%
        JSR SetUpIntteruptHandler
\end{lstlisting}

In plain English, an 'interrupt' is when the CPU periodically stops what ever its doing and does some other pre-defined amount
of work instead. There are a few such interrupts supported by the 6502 CPU but the one we make use of here is called the IRQ
or 'Hardware Interrupt'. This interrupt runs 60 times a second (that's right, 60 times a second) and already has some work
assigned to it by the Commodore 64, a set of tasks such as checking keyboard and joystick input that is defined at address \icode{\$EA31}.
This doesn't have a proper name of it's own so we will call it \icode{DEFAULT\_IRQ\_HANDLER}. (The routine called by an interrupt
is often referred to as an 'interrupt vector'.)

What we can do is tag some work of our own onto this, we still need to call the routine at \icode{\$EA31} but we can do some of our
own stuff before it. The way to do this is to load the address of our own routine, which we call \icode{MainInterruptHandler}, to
the address that the 6502 CPU consults each time it interrupts its work. We replace \icode{\$EA31} at that address with the address
of \icode{MainInterruptHandler}.  
\begin{lstlisting}[escapechar=\%]
        SEI 
        LDA #<MainInterruptHandler
        STA $0314    ;IRQ
        LDA #>MainInterruptHandler
        STA $0315    ;IRQ
        ...
        CLI 
\end{lstlisting}

Notice that because the address is two bytes long we must split it out, like we did for our Colour RAM address earlier, into 
two bytes and store each one separate in the consecutive address locations \icode{\$0314} and \icode{\$0315}, which store
the second and first byte of the interrupt-handler address respectively. 

The \icode{SEI} instruction at the beginning of this routine and the \icode{CLI} instruction at the end tell the CPU that we 
are updating the interrupt vector. The \icode{SEI} ensures that no further interrupts happen while we are doing this, and the
\icode{CLI} gives the CPU the all-clear to start honouring interrupts again now that we've updated the routine it should call
when one happens.


\clearpage
\textbf{Lines 491-506. \icode{\textbf{MainInterruptHandler}}}
\begin{lstlisting}[caption= This is our interrupt handler\, it runs 60 times a second so has to be fast.,escapechar=\%]
MainInterruptHandler   
        DEC countStepsBeforeCheckingJoystickInput%\index{countStepsBeforeCheckingJoystickInput}%
        BEQ PaintCursorAndCheckJoystickInput
        JMP DEFAULT_IRQ_HANDLER

PaintCursorAndCheckJoystickInput   
        LDA #$02
        STA countStepsBeforeCheckingJoystickInput%\index{countStepsBeforeCheckingJoystickInput}%
        LDA #$00
        STA currentColorToPaint%\index{currentColorToPaint}%
        JSR PaintCursorAtCurrentPosition%\index{PaintCursorAtCurrentPosition}%

CheckIfJoystickMovedUpOrDown   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$03
        CMP #$03
        BEQ CheckIfPlayerPressedLeftOrRight

        CMP #$02
        BEQ PlayerHasPressedDown

PlayerHasPressedUp
        ; Player has pressed up. Incremeent up two lines
        ; so that when we decrement down one, we're still
        ; one up!
        INC cursorYPosition%\index{cursorYPosition}%
        INC cursorYPosition%\index{cursorYPosition}%

PlayerHasPressedDown   
        DEC cursorYPosition%\index{cursorYPosition}%
        LDA cursorYPosition%\index{cursorYPosition}%
        CMP #$FF
        BNE CheckIfCursorAtBottom

WrapCursorToBottom
        ; Cursor has reached the top of the screen, so loop
        ; around to bottom.
        LDA #NUM_ROWS - 1
        STA cursorYPosition%\index{cursorYPosition}%
        JMP CheckIfPlayerPressedLeftOrRight

CheckIfCursorAtBottom   
        CMP #NUM_ROWS
        BNE CheckIfPlayerPressedLeftOrRight
        ; Cursor has reached the bottom of the screen, so loop
        ; around to top
        LDA #$00
        STA cursorYPosition%\index{cursorYPosition}%

\end{lstlisting}
\clearpage

\rhead[]{\icode{MainInterruptHandler}}
\textbf{Lines 491-506. \icode{\textbf{MainInterruptHandler}}:}  You don't have to look too hard at our interrupt handler
to divine what is is mainly concerned with: have you moved the joystick or pressed fire? The routine is long enough
that we need to spread it over 3 pages here. The section on the opposite page gets as far as reacting to any up or
down movement in the joystick and the beginnings of the left/right checks. 

Joystick input is read from the \icode{CIA1 Data Port Register}. If the player interacts with the joystick at all it will
show up in the byte at address \icode{\$DC00}. Only 5 of the 8 bits are used, 4 for each direction and 1 for the fire button.
Counter-intuitively, the bits are set to \icode{1} by default, so you can tell if a button has been pressed or the joystick moved
if one of the appropriate bits is \icode{0} rather than \icode{1}.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$FD & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
        \bottomrule
      \end{tabular}
    \end{adjustbox}
  }\caption*{The contents of \icode{\$DC00} when the player has pressed down on the joystick.}
\end{figure}

\textbf{Lines 491-506. \icode{\textbf{CheckIfJoystickMovedUpOrDown}}:} If we \icode{AND} the value in \icode{\$DC00} (for
example, \icode{\$FE}) with
\icode{\$03} it will tell us if up or down have been pressed if the result is not equal to \icode{\$03}. This is because
we expect both bits to be 1 if up or down have not been pressed, and the \icode{AND} ensures we are only comparing those
two bits when we perform \icode{CMP \#\$03}.
\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$FE & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
        \$03 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$FE and \$03 gives \$02, telling us that 'Up' has been pressed.}
\end{figure}

Once we have established this we can increment and decrement \icode{cursorYPosition\index{cursorYPosition}} as appropriate and also check
if we've reached the top or bottom of the screen. 
\clearpage
\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedLeftOrRight}}}
\begin{lstlisting}[caption= Second part of the Interrupt Handler.,escapechar=\%]
CheckIfPlayerPressedLeftOrRight   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$0C
        CMP #$0C
        BEQ CheckIfPlayerPressedFire%\index{CheckIfPlayerPressedFire}%

        CMP #$08
        BEQ PlayerHasPressedLeft

PlayerHasPressedRight
        ; Player has pressed right.
        INC cursorXPosition%\index{cursorXPosition}%
        INC cursorXPosition%\index{cursorXPosition}%

PlayerHasPressedLeft   
        DEC cursorXPosition%\index{cursorXPosition}%
        LDA cursorXPosition%\index{cursorXPosition}%
        CMP #$FF
        BNE CheckIfCursorAtExtremeRight

WrapCursorToExtremeRight
        LDA #NUM_COLS - 1
        STA cursorXPosition%\index{cursorXPosition}%
        JMP CheckIfPlayerPressedFire%\index{CheckIfPlayerPressedFire}%

CheckIfCursorAtExtremeRight   
        CMP #NUM_COLS
        BNE CheckIfPlayerPressedFire%\index{CheckIfPlayerPressedFire}%
        LDA #$00
        STA cursorXPosition%\index{cursorXPosition}%

\end{lstlisting}
\clearpage
\rhead[]{\icode{MainInterruptHandler} cont.}
\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedLeftOrRight}}:} As in the previous page, which was checking
for up/down movement, here we're checking for left/right movement in the joystick and updating the \icode{cursorXPosition\index{cursorXPosition}} if required.

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=7cm,center}

      \begin{tabular}{rllllllll}
        \toprule
        Byte & Bit 7 & Bit 6 & Bit 5 & Bit 4 & Bit 3 & Bit 2 & Bit 1 & Bit 0        \\
             &       &       &       & Fire  & Right & Left  & Down  & Up           \\
        \midrule
        \$F7 & 1 & 1 & 1 & 1 & 0 & 1 & 1 & 1 \\
        \$0C & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\
        \midrule
        Result & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        \addlinespace
        \bottomrule
      \end{tabular}
    \end{adjustbox}
    }\caption*{AND'ing \$F7 and \$0C gives \$04, telling us that 'Left' has been pressed.}
\end{figure}

\clearpage
\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedFire\index{CheckIfPlayerPressedFire}}}}
\begin{lstlisting}[caption= Third part of the Interrupt Handler.,escapechar=\%]
CheckIfPlayerPressedFire%\index{CheckIfPlayerPressedFire}%   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$10
        BEQ PlayerHasPressedFire

PlayerHasntPressedFire
        LDA #$00
        STA stepsSincePressedFire%\index{stepsSincePressedFire}%
        JMP DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%

PlayerHasPressedFire
MaybeUpdatePixelBuffers   
        LDA unusedBurstMode
        BEQ UpdateArrayIndex

        LDA stepsSincePressedFire%\index{stepsSincePressedFire}%
        BNE DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%
        INC stepsSincePressedFire%\index{stepsSincePressedFire}%

UpdateArrayIndex   
        INC indexIntoArrays
        LDA indexIntoArrays
        AND MAX_INDEX_VALUE
        STA indexIntoArrays

CheckCurrentIndexInBuffers  
        TAX 
        LDA currentColorIndexArray%\index{currentColorIndexArray}%,X
        CMP #$FF
        BNE DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%

UpdateBuffersWithCursorPosition
        LDA cursorXPosition%\index{cursorXPosition}%
        STA pixelXPositionArray%\index{pixelXPositionArray}%,X
        LDA cursorYPosition%\index{cursorYPosition}%
        STA pixelYPositionArray%\index{pixelYPositionArray}%,X
        LDA #COLOR_MAX
        STA currentColorIndexArray%\index{currentColorIndexArray}%,X

        LDA smoothingDelay%\index{smoothingDelay}%
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X

\end{lstlisting}
\clearpage

\rhead[]{\icode{MainInterruptHandler} cont.}
\textbf{Lines 300-313. \icode{\textbf{CheckIfPlayerPressedFire\index{CheckIfPlayerPressedFire}}}:} This section of the routine could be much shorter. This
is because neither \icode{burstModeEnabled} nor \icode{stepsSincePressedFire\index{stepsSincePressedFire}} are actually used. The code that refers
to them seems to be concerned with supporting an unused feature toggled on/off by the variable \icode{burstModeEnabled}
and since it has been hardcoded to \icode{\$00} the section could be stripped back to this instead:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,escapechar=\%]
CheckIfPlayerPressedFire%\index{CheckIfPlayerPressedFire}%   
        LDA $DC00    ;CIA1: Data Port Register A
        AND #$10
        BNE DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%

PlayerHasPressedFire
        INC indexIntoArrays
        LDA indexIntoArrays
        AND MAX_INDEX_VALUE
        STA indexIntoArrays

CheckCurrentIndexInBuffers  
        TAX 
        LDA currentColorIndexArray%\index{currentColorIndexArray}%,X
        CMP #$FF
        BNE DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%

UpdateBuffersWithCursorPosition
        LDA cursorXPosition%\index{cursorXPosition}%
        STA pixelXPositionArray%\index{pixelXPositionArray}%,X
        LDA cursorYPosition%\index{cursorYPosition}%
        STA pixelYPositionArray%\index{pixelYPositionArray}%,X
        LDA #COLOR_MAX
        STA currentColorIndexArray%\index{currentColorIndexArray}%,X

        LDA smoothingDelay%\index{smoothingDelay}%
        STA initialSmoothingDelayForStep,X
        STA smoothingDelayForStep,X
\end{lstlisting}

This refactored version makes it much easier to see what's going on: if the player has pressed fire then we increment
our index into the pixel arrays and load the cursor's position to the index's position in \icode{pixelXPositionArray\index{pixelXPositionArray}/pixelYPositionArray\index{pixelYPositionArray}}
and initial values to the arrays managing pixel color and smoothing delay.

If the player hasn't pressed fire or if our current index to the arrays points to a position that is already being used then
we skip to just painting the cursor and exiting. Note that our heuristic for deciding whether the current position in the 
arrays is in use is to make sure that the value at \icode{indexIntoArrays} in \icode{currentColorIndexArray\index{currentColorIndexArray}} is \icode{\$FF} - 
after all, this will only be the case if we haven't already used it (or used it up).

\clearpage
\textbf{Lines 300-313. \icode{\textbf{DrawCursorAndReturnFromInterrupt\index{DrawCursorAndReturnFromInterrupt}}}}
\begin{lstlisting}[caption = Paint the cursor and call the system default interrupt handler \icode{RETURN\_FROM\_INTERRUPT},escapechar=\%]
DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%   
        JSR LoadXAndYOfCursorPosition%\index{LoadXAndYOfCursorPosition}%
        LDA (currentLineForCursorInColorRamLoPtr),Y
        AND #COLOR_MAX
        STA lastColorPainted
        LDA #WHITE
        STA currentColorToPaint%\index{currentColorToPaint}%
        JSR PaintCursorAtCurrentPosition%\index{PaintCursorAtCurrentPosition}%
        JMP RETURN_FROM_INTERRUPT

\end{lstlisting}

\bigskip
\textbf{Lines 300-313. \icode{\textbf{LoadXAndYOfCursorPosition\index{LoadXAndYOfCursorPosition}}}}
\begin{lstlisting}[escapechar=\%][caption= Load the X and Y position and set up \icode{currentLineForCursorInColorRamLoPtr/currentLineForCursorInColorRamHiPtr}[escapechar=\%]
for painting the cursor.]
LoadXAndYOfCursorPosition%\index{LoadXAndYOfCursorPosition}%   
        LDX cursorYPosition%\index{cursorYPosition}%
        LDA colorRAMLineTableLoPtrArray%\index{colorRAMLineTableLoPtrArray}%,X
        STA currentLineForCursorInColorRamLoPtr
        LDA colorRAMLineTableHiPtrArray%\index{colorRAMLineTableHiPtrArray}%,X
        STA currentLineForCursorInColorRamHiPtr
        LDY cursorXPosition%\index{cursorXPosition}%
        RTS 
\end{lstlisting}
\bigskip
\textbf{Lines 300-313. \icode{\textbf{PaintCursorAtCurrentPosition\index{PaintCursorAtCurrentPosition}}}}
\begin{lstlisting}[caption = Paint the cursor.,escapechar=\%]
PaintCursorAtCurrentPosition%\index{PaintCursorAtCurrentPosition}%   
        JSR LoadXAndYOfCursorPosition%\index{LoadXAndYOfCursorPosition}%
        LDA currentColorToPaint%\index{currentColorToPaint}%
        STA (currentLineForCursorInColorRamLoPtr),Y
        RTS 
\end{lstlisting}
\clearpage

\rhead[]{\icode{DrawCursorAndReturnFromInterrupt\index{DrawCursorAndReturnFromInterrupt}}}
\textbf{Lines 300-313. \icode{\textbf{DrawCursorAndReturnFromInterrupt\index{DrawCursorAndReturnFromInterrupt}}}:} Drawing the cursor should be a relatively simple matter
of converting the cursor position stored in \icode{cursorXPosition\index{cursorXPosition}} and \icode{cursorYPosition\index{cursorYPosition}} to a position on the screen. Again
we have some redundant code to distract us: there is no good reason to determine the \icode{lastColorPainted} since we don't use it
for anything (and this code is not present in the commercial edition). So our simplified version of \icode{DrawCursor\-AndReturnFromInterrupt}
looks as follows:
\begin{lstlisting}[escapechar=\%]
DrawCursorAndReturnFromInterrupt%\index{DrawCursorAndReturnFromInterrupt}%   
        JSR LoadXAndYOfCursorPosition%\index{LoadXAndYOfCursorPosition}%
        LDA #WHITE
        STA currentColorToPaint%\index{currentColorToPaint}%
        JSR PaintCursorAtCurrentPosition%\index{PaintCursorAtCurrentPosition}%
        JMP RETURN_FROM_INTERRUPT
\end{lstlisting}

The real work is clearly done by our two helper routines \icode{LoadXAndYOfCursorPosition\index{LoadXAndYOfCursorPosition}} and \icode{PaintCursorAtCurrentPosition\index{PaintCursorAtCurrentPosition}}. 

Let's imagine our cursor has an \icode{cursorYPosition\index{cursorYPosition}} of 5 and an \icode{cursorXPosition\index{cursorXPosition}} of 10. This means in \icode{LoadXAndYOfCursorPosition\index{LoadXAndYOfCursorPosition}}
we will retrieve the elements with index 5 in \icode{colorRAMLineTableLoPtrArray\index{colorRAMLineTableLoPtrArray}} and \icode{colorRAMLineTableHiPtrArray\index{colorRAMLineTableHiPtrArray}}. So consulting
our table below we see the values we end up with in each highlighted in red:

\begin{figure}[H]
  {
    \setlength{\tabcolsep}{3.0pt}
    \setlength\cmidrulewidth{\heavyrulewidth} % Make cmidrule = 
    \begin{adjustbox}{width=8cm,center}
      \begin{tabular}{cccc}
        \toprule
        Element &
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{HiPtrArray}} & 
        \makecell[c]{\icode{colorRAMLineTable} \\ \icode{LoPtrArray}} & 
        Address \\
        \midrule
0 & \icode{\$D8} & \icode{\$00} & \icode{\$D800} \\ 
1 & \icode{\$D8} & \icode{\$28} & \icode{\$D828} \\ 
2 & \icode{\$D8} & \icode{\$50} & \icode{\$D850} \\ 
3 & \icode{\$D8} & \icode{\$78} & \icode{\$D878} \\ 
4 & \icode{\$D8} & \icode{\$A0} & \icode{\$D8A0} \\ 
        \textcolor{red}{5} & \textcolor{red}{\icode{\$D8}} & \textcolor{red}{\icode{\$C8}} & \textcolor{red}{\icode{\$D8C8}} \\ 
        \bottomrule
      \end{tabular}
    \end{adjustbox}
  }
\end{figure}
\vspace*{-\baselineskip}

With an address of \icode{\$D8C8} we now know where in Color RAM our line starts. We can now load our \icode{cursorXPosition\index{cursorXPosition}} to the
\icode{Y} register:
\begin{lstlisting}[escapechar=\%]
        LDY cursorXPosition%\index{cursorXPosition}%
\end{lstlisting}
And use that to paint the cursor position white. The address we want to paint is \icode{(currentLineForCursorInColorRamLoPtr)} + 
\icode{Y}, i.e. \icode{\$D8C8} + \icode{\$0A} = \icode{\$D8D2}. We express this in assembly as follows:
\begin{lstlisting}[escapechar=\%]
        LDA currentColorToPaint%\index{currentColorToPaint}%
        STA (currentLineForCursorInColorRamLoPtr),Y
\end{lstlisting}






